# Task 44: Generate Compelling AI Journal Summaries

## Description
Transform journal summary generation from basic statistics ("visited 3 places, took 2 photos") into compelling, narrative-driven content that captures the essence and emotional depth of the user's day using comprehensive data extraction and intelligent narrative generation.

## Priority
High

## Status
pending

## Problem Analysis

### Current State
- Summary generator uses basic template-based approach with dry, statistical output
- Narrative generation service exists but produces generic, formulaic text
- Rich data context available but underutilized (Timeline events, Location data, Calendar, Photos)
- Critical data extraction gaps: No photo object detection, limited photo geocoding
- No protection against accidental user content loss on regeneration
- Multiple narrative styles defined but all produce similar boring output
- No UI for regenerating or customizing summaries

### Example Current Output
```
"Your morning started with several activities. You spent time at Location A. You captured 2 memorable moments throughout the day."
```

### Desired Output
```
"This morning unfolded quietly at Harbor Roast Coffee on Main Street, where you lingered over your laptop during that 9am team meeting—those focused work sessions always feel longest in the moment. The afternoon brought movement and energy as you walked 2.3km through Golden Gate Park, camera in hand, capturing the golden light filtering through autumn leaves and a playful golden retriever chasing frisbees. Your calendar shows the product review meeting ran long, but you made it to yoga class at Sunset Studio by 5:30pm. By evening, the pace had slowed again, settling into the comfort of home with time to reflect on a day well-spent."
```

## Data Sources to Integrate

### 1. Timeline Events (CRITICAL - Primary narrative structure)
- Source: `TimelineWidget` / `JournalActivity` entries
- Contains: User activities, events, notes with timestamps
- Usage: Forms the chronological backbone of the narrative
- Integration: Each timeline event becomes a narrative beat

### 2. Location Data (CRITICAL - Geographic context)
- **Distance Traveled**: Calculate total km/miles from movement data
- **Locations Visited**: Use location clusters from `LocationDatabase`
- **Reverse Geocoding** (if enabled): Convert coordinates to place names
  - "Harbor Roast Coffee" vs "Location 37.123,-122.456"
  - "Golden Gate Park" vs generic "outdoor area"
- **Dwell Times**: How long at each location
- **Movement Patterns**: Walking, driving, stationary periods
- Integration: Weave specific place names and distances into narrative

### 3. Calendar Events (User-Controlled)
- Only include events from calendars user has toggled ON
- Source: `CalendarService.getEventsInRange()` with `enabledCalendarIds`
- Contains: Meeting titles, times, attendees, locations
- Usage: Anchor narrative with concrete scheduled activities
- Integration: "during that 9am team meeting" / "made it to yoga class at 5:30pm"

### 4. Photo Context (Enhanced with AI extraction)
- **Scene Labels**: Environments, settings, contexts
- **Object Detection**: Specific items in photos (dogs, food, books, etc.)
- **Photo Geocoding**: Extract GPS from EXIF, reverse geocode to place names
- **Social Context**: Selfie, group, solo indicators
- **Time of Day**: Morning light, sunset, evening shadows
- Integration: "capturing... a playful golden retriever chasing frisbees"

### 5. Written Content Protection
- **User Edits Detection**: Track if AI-generated summary has been modified
- **Preservation Logic**: Never overwrite user-edited content
- **Merge Strategy**: Offer to append/prepend new content, not replace
- Implementation: Store hash of AI-generated text, compare on regeneration

## Research Findings

### Existing Infrastructure
- `DailyContextSynthesizer` - Comprehensive data aggregation
- `NarrativeGenerationService` - Template-based generation (needs enhancement)
- `NarrativeTemplateEngine` - Simple narrative builder
- `TimelineWidget` - Timeline events display
- `LocationDatabase` - Location point storage and clustering
- `CalendarService` - Calendar integration with user controls
- `PhotoService` - Photo access and metadata
- `SummaryWidget` - UI display (needs regeneration UI + edit protection)

### Data Extraction Gaps
1. **Photo Object Detection**: Not currently implemented
   - Need: ML Kit Object Detection or TFLite model
   - Purpose: Rich photo descriptions beyond generic scene labels

2. **Photo Geocoding**: Limited implementation
   - Current: Basic EXIF coordinate extraction
   - Need: Reverse geocoding to place names
   - Purpose: "captured at Golden Gate Park" not "at 37.7694,-122.4862"

3. **Distance Calculation**: Exists but not exposed
   - Current: `LocationSummary.totalDistance` calculated
   - Need: Surface in narrative generation

4. **Calendar Integration**: Exists but not used in summaries
   - Current: Calendar events collected but ignored in narrative
   - Need: Weave into timeline narrative

## Technical Approach - REORDERED FOR DATA-FIRST

### Subtask 1: Enhanced Photo Data Extraction

**Goal**: Extract rich, descriptive data from photos to feed narrative generation.

**Implementation**:

1. **Object Detection Integration**:
   ```dart
   class PhotoObjectDetector {
     Future<List<DetectedObject>> detectObjects(String photoPath) {
       // Use google_mlkit_object_detection
       final inputImage = InputImage.fromFilePath(photoPath);
       final objectDetector = ObjectDetector(options: ObjectDetectorOptions(
         mode: DetectionMode.single,
         classifyObjects: true,
         multipleObjects: true,
       ));

       final objects = await objectDetector.processImage(inputImage);
       return objects.map((obj) => DetectedObject(
         label: obj.labels.first.text,
         confidence: obj.labels.first.confidence,
         boundingBox: obj.boundingBox,
       )).toList();
     }
   }
   ```

2. **Photo Geocoding Enhancement**:
   ```dart
   class PhotoGeocoder {
     Future<PhotoLocation> extractLocationData(MediaItem photo) async {
       // 1. Extract EXIF GPS coordinates
       final exif = await readExifFromFile(photo.path);
       final coords = exif.gpsCoordinates;

       // 2. Reverse geocode if enabled
       if (_isReverseGeocodingEnabled()) {
         final placemark = await _geocoder.placemarkFromCoordinates(
           coords.latitude,
           coords.longitude,
         );

         return PhotoLocation(
           coordinates: coords,
           placeName: _formatPlaceName(placemark),
           placeType: _inferPlaceType(placemark),
         );
       }

       return PhotoLocation(coordinates: coords);
     }

     String _formatPlaceName(Placemark p) {
       // "Harbor Roast Coffee" or "Golden Gate Park" or "Market St, SF"
       if (p.name != null && p.name.isNotEmpty) return p.name;
       if (p.thoroughfare != null) return '${p.thoroughfare}, ${p.locality}';
       return p.locality ?? 'Unknown Location';
     }
   }
   ```

3. **Enhanced PhotoContext**:
   ```dart
   class EnhancedPhotoContext extends PhotoContext {
     List<String> objectLabels;           // NEW: Detected objects
     PhotoLocation? location;              // NEW: Geocoded location
     String? placeName;                    // NEW: Human-readable place
     Map<String, double> objectConfidence; // NEW: Object detection confidence
   }
   ```

**Files to Create/Modify**:
- `lib/services/ai/photo_object_detector.dart` (new)
- `lib/services/photo_geocoder.dart` (new)
- `lib/services/ai_feature_extractor.dart` (enhance PhotoContext)
- `lib/database/media_database.dart` (store enhanced metadata)

**Dependencies**: google_mlkit_object_detection, geocoding packages

---

### Subtask 2: Location and Distance Data Integration

**Goal**: Calculate and expose geographic data for narrative generation.

**Implementation**:

1. **Distance Calculator Service**:
   ```dart
   class DistanceCalculator {
     DistanceStats calculateDayDistance(List<LocationPoint> points) {
       double totalMeters = 0;
       Duration movingTime = Duration.zero;
       Duration stationaryTime = Duration.zero;

       for (int i = 1; i < points.length; i++) {
         final distance = _haversineDistance(points[i-1], points[i]);
         totalMeters += distance;

         final timeDelta = points[i].timestamp.difference(points[i-1].timestamp);
         if (distance > 50) { // Moving threshold
           movingTime += timeDelta;
         } else {
           stationaryTime += timeDelta;
         }
       }

       return DistanceStats(
         totalKm: totalMeters / 1000,
         movingTime: movingTime,
         stationaryTime: stationaryTime,
       );
     }
   }
   ```

2. **Location Cluster Naming**:
   ```dart
   class LocationClusterNamer {
     Future<String> getPlaceName(LocationCluster cluster) async {
       // Use reverse geocoding if enabled
       if (_settings.reverseGeocodingEnabled) {
         final placemark = await _geocoder.placemarkFromCoordinates(
           cluster.centerLat,
           cluster.centerLon,
         );
         return _formatPlaceName(placemark);
       }

       // Fallback to generic description
       return 'Location ${cluster.id}';
     }
   }
   ```

3. **Enhanced LocationSummary**:
   ```dart
   class EnhancedLocationSummary extends LocationSummary {
     Map<String, String> placeNames;        // NEW: Cluster ID -> Place name
     double totalKilometers;                // NEW: Formatted distance
     List<String> movementModes;            // ENHANCE: Detailed modes
     Map<String, Duration> placeTimeSpent;  // ENHANCE: Use real names
   }
   ```

**Files to Create/Modify**:
- `lib/services/distance_calculator.dart` (new)
- `lib/services/location_cluster_namer.dart` (new)
- `lib/services/daily_context_synthesizer.dart` (enhance LocationSummary)

**Dependencies**: geocoding package (if not already added)

---

### Subtask 3: Timeline and Calendar Integration

**Goal**: Integrate timeline events and calendar data into narrative structure.

**Implementation**:

1. **Timeline Event Aggregator**:
   ```dart
   class TimelineEventAggregator {
     List<NarrativeEvent> aggregateEvents(
       List<JournalActivity> timeline,
       List<CalendarEventData> calendar,
       Set<String> enabledCalendarIds,
     ) {
       final events = <NarrativeEvent>[];

       // Add timeline events
       for (final activity in timeline) {
         events.add(NarrativeEvent.fromActivity(activity));
       }

       // Add enabled calendar events
       for (final calEvent in calendar) {
         if (enabledCalendarIds.contains(calEvent.calendarId)) {
           events.add(NarrativeEvent.fromCalendar(calEvent));
         }
       }

       // Sort chronologically
       events.sort((a, b) => a.timestamp.compareTo(b.timestamp));

       return events;
     }
   }
   ```

2. **Narrative Event Structure**:
   ```dart
   class NarrativeEvent {
     DateTime timestamp;
     String type; // timeline, calendar, photo, location
     String description;
     Map<String, dynamic> context;

     // Calendar-specific
     String? meetingTitle;
     List<String>? attendees;

     // Location-specific
     String? placeName;
     double? duration;

     // Photo-specific
     List<String>? objectsSeen;
     String? sceneDescription;
   }
   ```

3. **Calendar Integration in DailyContext**:
   ```dart
   // Modify DailyContextSynthesizer
   Future<DailyContext> synthesizeDailyContext({
     required DateTime date,
     required MediaDatabase mediaDatabase,
     required LocationDatabase locationDatabase,
     required List<DataActivity> activities,
     Set<String>? enabledCalendarIds, // PASS THIS THROUGH
   }) async {
     // ... existing code ...

     final calendarEvents = await _getCalendarEvents(
       startOfDay,
       endOfDay,
       enabledCalendarIds, // USE IT HERE
     );

     // ... rest of synthesis ...
   }
   ```

**Files to Create/Modify**:
- `lib/services/timeline_event_aggregator.dart` (new)
- `lib/models/narrative_event.dart` (new)
- `lib/services/daily_context_synthesizer.dart` (modify to use enabledCalendarIds)

---

### Subtask 4: User Edit Protection System

**Goal**: Prevent accidental loss of user-edited content on regeneration.

**Implementation**:

1. **Edit Detection**:
   ```dart
   class SummaryEditTracker {
     String? _originalAiGenerated;
     String? _userEdited;

     void trackGeneration(String aiSummary) {
       _originalAiGenerated = aiSummary;
       _lastGeneratedHash = _hash(aiSummary);
       _userEdited = null;
     }

     bool hasUserEdits(String currentSummary) {
       if (_originalAiGenerated == null) return true; // Assume edited
       return _hash(currentSummary) != _lastGeneratedHash;
     }

     String _hash(String content) {
       return sha256.convert(utf8.encode(content)).toString();
     }
   }
   ```

2. **Safe Regeneration Dialog**:
   ```dart
   Future<void> _handleRegenerationRequest(WidgetRef ref) async {
     final currentSummary = ref.read(summaryTextProvider);
     final hasEdits = ref.read(editTrackerProvider).hasUserEdits(currentSummary);

     if (hasEdits) {
       final action = await showDialog<RegenerationAction>(
         context: context,
         builder: (context) => RegenerationWarningDialog(
           currentSummary: currentSummary,
         ),
       );

       switch (action) {
         case RegenerationAction.replace:
           // User confirmed - replace everything
           await _regenerateSummary(ref);
           break;
         case RegenerationAction.append:
           // Keep user content, add new content
           await _appendGeneratedContent(ref);
           break;
         case RegenerationAction.cancel:
           // Do nothing
           break;
       }
     } else {
       // No edits - safe to regenerate
       await _regenerateSummary(ref);
     }
   }
   ```

3. **Warning Dialog**:
   ```dart
   class RegenerationWarningDialog extends StatelessWidget {
     Widget build(BuildContext context) {
       return AlertDialog(
         title: Text('You\'ve edited this summary'),
         content: Column(
           children: [
             Text('Your custom edits will be lost if you regenerate.'),
             SizedBox(height: 16),
             Text('What would you like to do?'),
           ],
         ),
         actions: [
           TextButton(
             child: Text('Cancel'),
             onPressed: () => Navigator.pop(context, RegenerationAction.cancel),
           ),
           TextButton(
             child: Text('Add to my edits'),
             onPressed: () => Navigator.pop(context, RegenerationAction.append),
           ),
           TextButton(
             child: Text('Replace everything'),
             style: TextButton.styleFrom(foregroundColor: Colors.red),
             onPressed: () => Navigator.pop(context, RegenerationAction.replace),
           ),
         ],
       );
     }
   }
   ```

4. **Database Schema Update**:
   ```dart
   // In journal_database.dart
   class JournalEntries extends Table {
     // ... existing columns ...

     TextColumn get summary => text().nullable()();
     TextColumn get originalAiSummary => text().nullable()(); // NEW: Track original
     BoolColumn get summaryWasEdited => boolean().withDefault(const Constant(false))(); // NEW: Edit flag
   }
   ```

**Files to Create/Modify**:
- `lib/services/summary_edit_tracker.dart` (new)
- `lib/widgets/regeneration_warning_dialog.dart` (new)
- `lib/database/journal_database.dart` (add columns)
- `lib/widgets/daily_canvas/summary_widget.dart` (integrate protection)

---

### Subtask 5: Enhanced Narrative Template Engine

**Goal**: Create rich, contextual narrative templates using ALL available data.

**Implementation**:

1. **Data-Rich Narrative Builder**:
   ```dart
   class DataRichNarrativeBuilder {
     String buildNarrative(
       List<NarrativeEvent> events,
       EnhancedLocationSummary locations,
       List<EnhancedPhotoContext> photos,
       DistanceStats distance,
     ) {
       final buffer = StringBuffer();

       // Opening with time and location context
       buffer.writeln(_buildOpening(events, locations));

       // Chronological narrative with all data woven in
       for (int i = 0; i < events.length; i++) {
         final event = events[i];
         final nextEvent = i < events.length - 1 ? events[i + 1] : null;

         buffer.writeln(_describeEvent(
           event,
           nextEvent,
           _findRelevantPhotos(photos, event),
           _findRelevantLocation(locations, event),
         ));
       }

       // Closing with day summary stats
       buffer.writeln(_buildClosing(distance, photos, locations));

       return buffer.toString();
     }

     String _describeEvent(
       NarrativeEvent event,
       NarrativeEvent? nextEvent,
       List<EnhancedPhotoContext> photos,
       String? placeName,
     ) {
       switch (event.type) {
         case 'calendar':
           return _describeCalendarEvent(event, placeName);
         case 'photo':
           return _describePhotoMoment(photos, event);
         case 'location':
           return _describeLocationStay(event, placeName);
         default:
           return _describeTimelineActivity(event);
       }
     }

     String _describeCalendarEvent(NarrativeEvent event, String? place) {
       final time = DateFormat('h:mma').format(event.timestamp);
       final location = place ?? event.context['location'] ?? '';

       if (event.attendees != null && event.attendees!.isNotEmpty) {
         return 'At $time, ${event.meetingTitle} with ${event.attendees!.length} others${location.isNotEmpty ? " at $location" : ""}';
       }

       return 'Your $time ${event.meetingTitle}${location.isNotEmpty ? " at $location" : ""}';
     }

     String _describePhotoMoment(List<EnhancedPhotoContext> photos, NarrativeEvent event) {
       if (photos.isEmpty) return '';

       final photo = photos.first;
       final objects = photo.objectLabels.take(2).join(' and ');
       final scene = photo.sceneLabels.first;
       final place = photo.placeName ?? 'this location';

       return 'Captured ${objects.isNotEmpty ? objects : "the moment"} in the $scene at $place';
     }
   }
   ```

2. **Contextual Phrase Generator**:
   ```dart
   class ContextualPhraseGenerator {
     String generateTransition(NarrativeEvent from, NarrativeEvent to, double distanceKm) {
       final timeDiff = to.timestamp.difference(from.timestamp);

       if (distanceKm > 5) {
         return 'After traveling ${distanceKm.toStringAsFixed(1)}km,';
       } else if (timeDiff.inHours > 2) {
         return '${_formatDuration(timeDiff)} later,';
       } else if (distanceKm > 1) {
         return 'A short distance away,';
       } else {
         return 'Shortly after,';
       }
     }

     String describeTimeOfDay(DateTime time) {
       final hour = time.hour;
       if (hour < 6) return 'in the pre-dawn hours';
       if (hour < 9) return 'in the early morning';
       if (hour < 12) return 'mid-morning';
       if (hour < 14) return 'around midday';
       if (hour < 17) return 'in the afternoon';
       if (hour < 19) return 'as evening approached';
       if (hour < 22) return 'in the evening';
       return 'late at night';
     }
   }
   ```

**Files to Create/Modify**:
- `lib/services/data_rich_narrative_builder.dart` (new)
- `lib/services/contextual_phrase_generator.dart` (new)
- `lib/services/narrative_template_engine.dart` (major enhancement)

---

### Subtask 6: Personality and Emotional Intelligence

**Goal**: Add depth, personality, and emotional awareness to generated text.

**Implementation**:
(Same as before but now uses richer data from subtasks 1-3)

1. **Enhanced Emotional Tone Analyzer**:
   ```dart
   class EmotionalToneAnalyzer {
     EmotionalProfile analyzeDay(
       DailyContext context,
       DistanceStats distance,
       List<EnhancedPhotoContext> photos,
     ) {
       // Now has richer data to work with:
       // - Specific objects in photos (happy dogs = joy)
       // - Actual place names (coffee shop = calm, gym = energetic)
       // - Calendar meeting titles (performance review = stress)
       // - Distance traveled (15km = adventurous, 0.5km = sedentary)

       return EmotionalProfile(
         energy: _calculateEnergy(distance, context.movementData),
         social: _calculateSocial(photos, context.calendarEvents),
         contemplative: _calculateContemplative(context.writtenContentSummary),
         adventurous: _calculateAdventure(distance, photos),
       );
     }
   }
   ```

**Files to Create/Modify**:
- `lib/services/ai/emotional_tone_analyzer.dart` (new, enhanced with richer data)
- `lib/services/ai/personality_engine.dart` (new)

---

### Subtask 7: Summary Regeneration UI with Style Options

**Goal**: Build UI for regeneration with edit protection and style control.

**Implementation**:
(Enhanced with edit protection from Subtask 4)

1. **Regeneration Button with Edit Warning**:
   ```dart
   IconButton(
     icon: Icon(Icons.refresh),
     onPressed: () => _handleRegenerationRequest(context, ref),
     tooltip: 'Regenerate summary',
   )
   ```

2. **Style Picker with Data Preview**:
   ```dart
   class StylePickerSheet extends ConsumerWidget {
     Widget build(BuildContext context, WidgetRef ref) {
       final availableData = ref.watch(dataAvailabilityProvider);

       return Column(
         children: [
           Text('Regenerate with style:'),
           SizedBox(height: 8),

           // Show what data will be included
           DataInclusionCard(
             timelineEvents: availableData.timelineEvents,
             locations: availableData.locations,
             distance: availableData.totalDistance,
             photos: availableData.photoCount,
             calendar: availableData.calendarEvents,
           ),

           // Style options
           ...SummaryStyle.values.map((style) =>
             StyleOptionTile(
               style: style,
               onSelect: () => _regenerate(context, ref, style),
             ),
           ),
         ],
       );
     }
   }
   ```

**Files to Create/Modify**:
- `lib/widgets/daily_canvas/summary_widget.dart` (add regeneration with protection)
- `lib/widgets/daily_canvas/style_picker_sheet.dart` (new)
- `lib/widgets/daily_canvas/data_inclusion_card.dart` (new - show what's included)

## Success Criteria

### Functional Requirements
- [ ] Photo object detection extracts meaningful objects from images
- [ ] Photo geocoding provides human-readable place names
- [ ] Distance traveled calculated and displayed in narrative
- [ ] Timeline events form narrative backbone
- [ ] Calendar events (only enabled) woven into narrative
- [ ] User edits are never lost on accidental regeneration
- [ ] Regeneration shows warning dialog if content was edited
- [ ] Generated summaries tell coherent story with narrative flow
- [ ] Users can regenerate with different styles

### Quality Metrics
- [ ] Summary length: 150-300 words (vs current 20-50)
- [ ] Specific place names: ≥3 per day (when geocoding enabled)
- [ ] Object mentions: ≥2 per photo with objects
- [ ] Distance accuracy: ±5% of actual
- [ ] Calendar integration: 100% of enabled events mentioned
- [ ] Timeline integration: ≥80% of events incorporated
- [ ] Edit protection: 100% success rate (no accidental losses)
- [ ] Unique vocabulary: >80% unique words
- [ ] Detail density: 3+ specific details per major segment

### User Experience
- [ ] Summaries feel personal and authentic
- [ ] Place names are recognizable and accurate
- [ ] Reading summaries evokes memories with specific details
- [ ] Edit warning is clear and prevents accidental loss
- [ ] Regeneration takes <3 seconds
- [ ] Style picker shows what data will be included

## Testing Strategy

1. **Unit Tests**:
   - PhotoObjectDetector returns valid object labels
   - PhotoGeocoder produces accurate place names
   - DistanceCalculator matches manual calculations
   - EditTracker correctly detects modifications
   - Warning dialog appears when content is edited

2. **Integration Tests**:
   - Full pipeline: data extraction → narrative generation
   - Calendar filtering by enabledCalendarIds works
   - Edit protection prevents data loss
   - Style switching preserves data accuracy

3. **Manual Testing**:
   - Test with days having various data completeness levels
   - Verify place names match reality
   - Verify distance calculations accurate
   - Test edit protection across regeneration scenarios
   - Verify calendar events only from enabled calendars appear

4. **Data Accuracy Testing**:
   - Compare generated place names with Google Maps
   - Verify object detection against manual photo review
   - Validate distance against Google Timeline
   - Check calendar event details match source

## Implementation Order (REORDERED - DATA FIRST)

### Phase 1: Data Extraction (Foundation)
1. **Subtask 1**: Enhanced Photo Data Extraction
2. **Subtask 2**: Location and Distance Data Integration
3. **Subtask 3**: Timeline and Calendar Integration

### Phase 2: Protection & Intelligence
4. **Subtask 4**: User Edit Protection System
5. **Subtask 6**: Personality and Emotional Intelligence

### Phase 3: Narrative Generation
6. **Subtask 5**: Enhanced Narrative Template Engine

### Phase 4: User Control
7. **Subtask 7**: Summary Regeneration UI with Style Options

**Rationale**: Extract rich data first, then build narrative system that uses it, finally add user controls.

## Dependencies
- google_mlkit_object_detection (NEW - object detection)
- geocoding (NEW - reverse geocoding)
- crypto (NEW - edit tracking hashes)
- Existing: DailyContextSynthesizer, NarrativeGenerationService, SummaryWidget
- flutter_background_geolocation (location data)
- photo_manager (photo access)

## Critical User Experience Rules

1. **NEVER lose user edits**: Edit protection is mandatory, not optional
2. **ALWAYS show what data is included**: Users should know what's being used
3. **ALWAYS use enabled calendars only**: Respect user's calendar privacy settings
4. **ALWAYS format distances human-readable**: "2.3km" not "2300 meters"
5. **ALWAYS use place names when available**: "Golden Gate Park" not "Location 42"

## Notes
- Prioritize data extraction before narrative generation
- Use template-based approach with rich data
- Consider caching generated summaries with data fingerprint
- Store original AI text for edit detection
- Make edit protection prominent and clear
- Show data availability in UI to manage expectations
