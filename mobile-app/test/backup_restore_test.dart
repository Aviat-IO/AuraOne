import 'package:flutter_test/flutter_test.dart';
import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:mobile_app/database/journal_database.dart';
import 'package:mobile_app/database/media_database.dart';
import 'package:mobile_app/database/location_database.dart';
import 'package:mobile_app/services/backup/backup_manager.dart';
import 'package:mobile_app/services/backup/backup_restoration_service.dart';

void main() {
  late JournalDatabase journalDb;
  late MediaDatabase mediaDb;
  late LocationDatabase locationDb;
  late BackupManager backupManager;
  late BackupRestorationService restorationService;

  setUp(() {
    // Create in-memory databases for testing
    journalDb = JournalDatabase.forTesting(NativeDatabase.memory());
    mediaDb = MediaDatabase.forTesting(NativeDatabase.memory());
    locationDb = LocationDatabase.forTesting(NativeDatabase.memory());

    backupManager = BackupManager.instance;
    restorationService = BackupRestorationService();
  });

  tearDown(() async {
    await journalDb.close();
    await mediaDb.close();
    await locationDb.close();
  });

  group('Backup and Restore', () {
    test('should create backup with journal entries', () async {
      // Insert test data
      final entry = await journalDb.insertJournalEntry(
        JournalEntriesCompanion.insert(
          date: DateTime.now(),
          title: 'Test Entry',
          content: 'This is a test journal entry',
          mood: const Value('happy'),
          tags: Value('["test", "backup"]'),
        ),
      );

      expect(entry, greaterThan(0));

      // Create backup
      final backupData = await backupManager.performBackup(
        providers: [BackupProvider.local],
        incremental: false,
      );

      expect(backupData, isNotEmpty);
      expect(backupData.containsKey(BackupProvider.local), isTrue);

      final metadata = backupData[BackupProvider.local]!;
      expect(metadata.entryCount, equals(1));
    });

    test('should restore backup data correctly', () async {
      // Create sample backup data
      final backupData = {
        'journalEntries': [
          {
            'id': '1',
            'date': DateTime.now().toIso8601String(),
            'title': 'Restored Entry',
            'content': 'This entry was restored from backup',
            'mood': 'excited',
            'tags': ['restore', 'test'],
            'summary': null,
            'isAutoGenerated': false,
            'isEdited': false,
            'createdAt': DateTime.now().toIso8601String(),
            'updatedAt': DateTime.now().toIso8601String(),
          }
        ],
        'journalActivities': [],
        'mediaReferences': [],
        'locationSummaries': [],
        'locationNotes': [],
        'metadata': {
          'version': '1.0.0',
          'timestamp': DateTime.now().toIso8601String(),
        },
      };

      // Execute restore
      final result = await restorationService.executeRestore(
        backupData: backupData,
        strategy: RestoreStrategy.merge,
        conflictResolution: ConflictResolution.useNewer,
        onProgress: (processed, total, item) {
          // Track progress
        },
      );

      expect(result['entries'], equals(1));

      // Verify entry was restored
      final entries = await journalDb.select(journalDb.journalEntries).get();
      expect(entries.length, equals(1));
      expect(entries.first.title, equals('Restored Entry'));
    });

    test('should handle incremental backups', () async {
      // Create initial backup
      await journalDb.insertJournalEntry(
        JournalEntriesCompanion.insert(
          date: DateTime.now().subtract(const Duration(days: 2)),
          title: 'Old Entry',
          content: 'This is an old entry',
        ),
      );

      final firstBackup = await backupManager.performBackup(
        providers: [BackupProvider.local],
        incremental: false,
      );

      expect(firstBackup[BackupProvider.local]!.entryCount, equals(1));

      // Add new entry
      await journalDb.insertJournalEntry(
        JournalEntriesCompanion.insert(
          date: DateTime.now(),
          title: 'New Entry',
          content: 'This is a new entry',
        ),
      );

      // Create incremental backup
      final incrementalBackup = await backupManager.performBackup(
        providers: [BackupProvider.local],
        incremental: true,
      );

      // Incremental backup should contain new data
      expect(incrementalBackup[BackupProvider.local]!.isFullBackup, isFalse);
    });

    test('should handle conflict resolution strategies', () async {
      // Insert initial entry
      final date = DateTime.now();
      await journalDb.insertJournalEntry(
        JournalEntriesCompanion.insert(
          date: date,
          title: 'Original Entry',
          content: 'Original content',
        ),
      );

      // Create backup data with same date but different content
      final backupData = {
        'journalEntries': [
          {
            'id': '1',
            'date': date.toIso8601String(),
            'title': 'Backup Entry',
            'content': 'Backup content',
            'mood': 'happy',
            'tags': [],
            'summary': null,
            'isAutoGenerated': false,
            'isEdited': false,
            'createdAt': date.toIso8601String(),
            'updatedAt': date.add(const Duration(hours: 1)).toIso8601String(),
          }
        ],
        'journalActivities': [],
        'mediaReferences': [],
        'locationSummaries': [],
        'locationNotes': [],
      };

      // Test different conflict resolution strategies
      // 1. Keep existing
      await restorationService.executeRestore(
        backupData: backupData,
        strategy: RestoreStrategy.merge,
        conflictResolution: ConflictResolution.keepExisting,
        onProgress: (_, __, ___) {},
      );

      var entry = await journalDb.getJournalEntryForDate(date);
      expect(entry!.title, equals('Original Entry'));

      // 2. Use backup
      await restorationService.executeRestore(
        backupData: backupData,
        strategy: RestoreStrategy.merge,
        conflictResolution: ConflictResolution.useBackup,
        onProgress: (_, __, ___) {},
      );

      entry = await journalDb.getJournalEntryForDate(date);
      expect(entry!.title, equals('Backup Entry'));
    });
  });
}