import 'package:drift/drift.dart';
import 'package:drift_flutter/drift_flutter.dart';

part 'journal_database.g.dart';

// Table for storing daily journal entries
class JournalEntries extends Table {
  IntColumn get id => integer().autoIncrement()();
  DateTimeColumn get date => dateTime()(); // Date of the journal entry (without time)
  TextColumn get title => text()();
  TextColumn get content => text()();
  TextColumn get mood => text().nullable()(); // Overall mood/sentiment
  TextColumn get tags => text().nullable()(); // JSON array of tags
  TextColumn get summary => text().nullable()(); // AI-generated summary
  BoolColumn get isAutoGenerated => boolean().withDefault(const Constant(true))(); // Auto vs user created
  BoolColumn get isEdited => boolean().withDefault(const Constant(false))(); // User has edited
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
  DateTimeColumn get updatedAt => dateTime().withDefault(currentDateAndTime)();

  @override
  List<Set<Column>> get uniqueKeys => [
    {date}, // One entry per date
  ];
}

// Table for journal entry activities/events
class JournalActivities extends Table {
  IntColumn get id => integer().autoIncrement()();
  IntColumn get journalEntryId => integer().references(JournalEntries, #id, onDelete: KeyAction.cascade)();
  TextColumn get activityType => text()(); // 'location', 'photo', 'movement', 'calendar', 'manual'
  TextColumn get description => text()();
  TextColumn get metadata => text().nullable()(); // JSON with activity-specific data
  DateTimeColumn get timestamp => dateTime()();
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
}

// Table for user-defined journal templates
class JournalTemplates extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get name => text()();
  TextColumn get description => text().nullable()();
  TextColumn get prompt => text()(); // Template text with placeholders
  BoolColumn get isActive => boolean().withDefault(const Constant(true))();
  IntColumn get usageCount => integer().withDefault(const Constant(0))();
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
  DateTimeColumn get lastUsedAt => dateTime().nullable()();
}

@DriftDatabase(tables: [
  JournalEntries,
  JournalActivities,
  JournalTemplates,
])
class JournalDatabase extends _$JournalDatabase {
  JournalDatabase() : super(_openConnection());

  @override
  int get schemaVersion => 1;

  static QueryExecutor _openConnection() {
    return driftDatabase(name: 'journal_database');
  }

  // Journal Entries Methods
  Future<int> insertJournalEntry(JournalEntriesCompanion entry) {
    return into(journalEntries).insert(entry, mode: InsertMode.insertOrReplace);
  }

  Future<bool> updateJournalEntry(JournalEntriesCompanion entry) {
    return update(journalEntries).replace(entry);
  }

  Future<JournalEntry?> getJournalEntryForDate(DateTime date) async {
    final dateOnly = DateTime(date.year, date.month, date.day);
    return await (select(journalEntries)
          ..where((tbl) => tbl.date.equals(dateOnly)))
        .getSingleOrNull();
  }

  Stream<JournalEntry?> watchJournalEntryForDate(DateTime date) {
    final dateOnly = DateTime(date.year, date.month, date.day);
    return (select(journalEntries)
          ..where((tbl) => tbl.date.equals(dateOnly)))
        .watchSingleOrNull();
  }

  Stream<List<JournalEntry>> watchRecentJournalEntries({
    int limit = 30,
  }) {
    return (select(journalEntries)
          ..orderBy([(tbl) => OrderingTerm.desc(tbl.date)])
          ..limit(limit))
        .watch();
  }

  Future<List<JournalEntry>> getJournalEntriesBetween(
    DateTime startDate,
    DateTime endDate,
  ) {
    final start = DateTime(startDate.year, startDate.month, startDate.day);
    final end = DateTime(endDate.year, endDate.month, endDate.day);

    return (select(journalEntries)
          ..where((tbl) => tbl.date.isBetweenValues(start, end))
          ..orderBy([(tbl) => OrderingTerm.asc(tbl.date)]))
        .get();
  }

  Future<JournalEntry?> getLatestJournalEntry() async {
    return await (select(journalEntries)
          ..orderBy([(tbl) => OrderingTerm.desc(tbl.date)])
          ..limit(1))
        .getSingleOrNull();
  }

  Future<List<JournalEntry>> searchJournalEntries(String query) {
    final lowerQuery = query.toLowerCase();
    return (select(journalEntries)
          ..where((tbl) =>
              tbl.title.lower().contains(lowerQuery) |
              tbl.content.lower().contains(lowerQuery) |
              tbl.tags.lower().contains(lowerQuery) |
              (tbl.mood.isNotNull() & tbl.mood.lower().contains(lowerQuery)))
          ..orderBy([(tbl) => OrderingTerm.desc(tbl.date)]))
        .get();
  }

  // Journal Activities Methods
  Future<int> insertJournalActivity(JournalActivitiesCompanion activity) {
    return into(journalActivities).insert(activity);
  }

  Future<List<JournalActivity>> getActivitiesForEntry(int journalEntryId) {
    return (select(journalActivities)
          ..where((tbl) => tbl.journalEntryId.equals(journalEntryId))
          ..orderBy([(tbl) => OrderingTerm.asc(tbl.timestamp)]))
        .get();
  }

  Stream<List<JournalActivity>> watchActivitiesForEntry(int journalEntryId) {
    return (select(journalActivities)
          ..where((tbl) => tbl.journalEntryId.equals(journalEntryId))
          ..orderBy([(tbl) => OrderingTerm.asc(tbl.timestamp)]))
        .watch();
  }

  // Journal Templates Methods
  Future<int> insertJournalTemplate(JournalTemplatesCompanion template) {
    return into(journalTemplates).insert(template);
  }

  Stream<List<JournalTemplate>> watchActiveTemplates() {
    return (select(journalTemplates)
          ..where((tbl) => tbl.isActive.equals(true))
          ..orderBy([(tbl) => OrderingTerm.desc(tbl.usageCount)]))
        .watch();
  }

  Future<void> incrementTemplateUsage(int templateId) async {
    await (update(journalTemplates)
          ..where((tbl) => tbl.id.equals(templateId)))
        .write(JournalTemplatesCompanion(
          usageCount: Value(1), // This will increment by 1
          lastUsedAt: Value(DateTime.now()),
        ));
  }

  // Statistics Methods
  Future<Map<String, int>> getJournalStatistics() async {
    final totalEntries = await (selectOnly(journalEntries)
          ..addColumns([journalEntries.id.count()]))
        .getSingle();

    final autoGenerated = await (selectOnly(journalEntries)
          ..addColumns([journalEntries.id.count()])
          ..where(journalEntries.isAutoGenerated.equals(true)))
        .getSingle();

    final edited = await (selectOnly(journalEntries)
          ..addColumns([journalEntries.id.count()])
          ..where(journalEntries.isEdited.equals(true)))
        .getSingle();

    final thisMonth = DateTime.now();
    final startOfMonth = DateTime(thisMonth.year, thisMonth.month, 1);
    final entriesThisMonth = await (selectOnly(journalEntries)
          ..addColumns([journalEntries.id.count()])
          ..where(journalEntries.date.isBiggerOrEqualValue(startOfMonth)))
        .getSingle();

    return {
      'total_entries': totalEntries.read(journalEntries.id.count()) ?? 0,
      'auto_generated': autoGenerated.read(journalEntries.id.count()) ?? 0,
      'user_edited': edited.read(journalEntries.id.count()) ?? 0,
      'this_month': entriesThisMonth.read(journalEntries.id.count()) ?? 0,
    };
  }

  // Data cleanup methods
  Future<void> cleanupOldEntries({
    Duration retentionPeriod = const Duration(days: 365),
  }) async {
    final cutoff = DateTime.now().subtract(retentionPeriod);

    await (delete(journalEntries)
          ..where((tbl) => tbl.date.isSmallerThanValue(cutoff)))
        .go();
  }

  // Migration and schema updates
  @override
  MigrationStrategy get migration => MigrationStrategy(
        onCreate: (Migrator m) async {
          await m.createAll();

          // Create indices for better performance
          await customStatement('''
            CREATE INDEX idx_journal_entries_date ON journal_entries(date DESC);
          ''');
          await customStatement('''
            CREATE INDEX idx_journal_entries_created_at ON journal_entries(created_at DESC);
          ''');
          await customStatement('''
            CREATE INDEX idx_journal_activities_entry_timestamp ON journal_activities(journal_entry_id, timestamp);
          ''');
          await customStatement('''
            CREATE INDEX idx_journal_templates_active_usage ON journal_templates(is_active, usage_count DESC);
          ''');
        },
        onUpgrade: (Migrator m, int from, int to) async {
          // Handle future schema updates
        },
      );
}