import 'package:drift/drift.dart';
import 'package:drift_flutter/drift_flutter.dart';
import '../utils/date_utils.dart';

part 'journal_database.g.dart';

// Table for storing daily journal entries
class JournalEntries extends Table {
  IntColumn get id => integer().autoIncrement()();
  DateTimeColumn get date => dateTime()(); // Date of the journal entry (without time)
  TextColumn get title => text()();
  TextColumn get content => text()();
  TextColumn get mood => text().nullable()(); // Overall mood/sentiment
  TextColumn get tags => text().nullable()(); // JSON array of tags
  TextColumn get summary => text().nullable()(); // AI-generated summary
  BoolColumn get isAutoGenerated => boolean().withDefault(const Constant(true))(); // Auto vs user created
  BoolColumn get isEdited => boolean().withDefault(const Constant(false))(); // User has edited
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
  DateTimeColumn get updatedAt => dateTime().withDefault(currentDateAndTime)();

  @override
  List<Set<Column>> get uniqueKeys => [
    {date}, // One entry per date
  ];
}

// Table for journal entry activities/events
class JournalActivities extends Table {
  IntColumn get id => integer().autoIncrement()();
  IntColumn get journalEntryId => integer().references(JournalEntries, #id, onDelete: KeyAction.cascade)();
  TextColumn get activityType => text()(); // 'location', 'photo', 'movement', 'calendar', 'manual'
  TextColumn get description => text()();
  TextColumn get metadata => text().nullable()(); // JSON with activity-specific data
  DateTimeColumn get timestamp => dateTime()();
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
}

// Table for user-defined journal templates
class JournalTemplates extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get name => text()();
  TextColumn get description => text().nullable()();
  TextColumn get prompt => text()(); // Template text with placeholders
  BoolColumn get isActive => boolean().withDefault(const Constant(true))();
  IntColumn get usageCount => integer().withDefault(const Constant(0))();
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
  DateTimeColumn get lastUsedAt => dateTime().nullable()();
}

@DriftDatabase(
  tables: [
    JournalEntries,
    JournalActivities,
    JournalTemplates,
  ],
  include: {'search_tables.drift'},
)
class JournalDatabase extends _$JournalDatabase {
  JournalDatabase() : super(_openConnection());

  // Constructor for testing with custom executor
  JournalDatabase.forTesting(QueryExecutor e) : super(e);

  @override
  int get schemaVersion => 2;

  static QueryExecutor _openConnection() {
    return driftDatabase(name: 'journal_database');
  }

  // Journal Entries Methods
  Future<int> insertJournalEntry(JournalEntriesCompanion entry) {
    return into(journalEntries).insert(entry, mode: InsertMode.insertOrReplace);
  }

  Future<bool> updateJournalEntry(JournalEntriesCompanion entry) async {
    final updatedRows = await (update(journalEntries)
          ..where((tbl) => tbl.id.equals(entry.id.value)))
        .write(entry);
    return updatedRows > 0;
  }

  Future<JournalEntry?> getJournalEntryForDate(DateTime date) async {
    // Convert local date to UTC for database query
    final utcDate = DateTimeUtils.localDateToUtc(date);
    // Strip time component for date-only comparison
    final dateOnly = DateTime(utcDate.year, utcDate.month, utcDate.day);
    return await (select(journalEntries)
          ..where((tbl) => tbl.date.equals(dateOnly)))
        .getSingleOrNull();
  }

  Stream<JournalEntry?> watchJournalEntryForDate(DateTime date) {
    // Convert local date to UTC for database query
    final utcDate = DateTimeUtils.localDateToUtc(date);
    // Strip time component for date-only comparison
    final dateOnly = DateTime(utcDate.year, utcDate.month, utcDate.day);
    return (select(journalEntries)
          ..where((tbl) => tbl.date.equals(dateOnly)))
        .watchSingleOrNull();
  }

  Stream<List<JournalEntry>> watchRecentJournalEntries({
    int limit = 30,
  }) {
    return (select(journalEntries)
          ..orderBy([(tbl) => OrderingTerm.desc(tbl.date)])
          ..limit(limit))
        .watch();
  }

  Future<List<JournalEntry>> getJournalEntriesBetween(
    DateTime startDate,
    DateTime endDate,
  ) {
    // Convert local dates to UTC for database query
    final startUtc = DateTimeUtils.localDateToUtc(startDate);
    final endUtc = DateTimeUtils.localDateToUtc(endDate);
    final start = DateTime(startUtc.year, startUtc.month, startUtc.day);
    final end = DateTime(endUtc.year, endUtc.month, endUtc.day);

    return (select(journalEntries)
          ..where((tbl) => tbl.date.isBetweenValues(start, end))
          ..orderBy([(tbl) => OrderingTerm.asc(tbl.date)]))
        .get();
  }

  Future<JournalEntry?> getLatestJournalEntry() async {
    return await (select(journalEntries)
          ..orderBy([(tbl) => OrderingTerm.desc(tbl.date)])
          ..limit(1))
        .getSingleOrNull();
  }

  Future<List<JournalEntry>> searchJournalEntries(String query) {
    final lowerQuery = query.toLowerCase();
    return (select(journalEntries)
          ..where((tbl) =>
              tbl.title.lower().contains(lowerQuery) |
              tbl.content.lower().contains(lowerQuery))
          ..orderBy([(tbl) => OrderingTerm.desc(tbl.date)]))
        .get();
  }

  // FTS5-based search for journal entries
  Future<List<JournalEntry>> searchJournalEntriesFts(String query, {int limit = 50}) async {
    final results = await customSelect(
      '''
      SELECT
        je.id,
        je.date,
        je.title,
        je.content,
        je.mood,
        je.tags,
        je.summary,
        je.is_auto_generated,
        je.is_edited,
        je.created_at,
        je.updated_at,
        bm25(journal_search) as rank,
        snippet(journal_search, 1, '[', ']', '...', 32) as title_snippet,
        snippet(journal_search, 2, '[', ']', '...', 64) as content_snippet
      FROM journal_search js
      JOIN journal_entries je ON js.entry_id = je.id
      WHERE journal_search MATCH ?
      ORDER BY rank
      LIMIT ?
      ''',
      variables: [Variable.withString(query), Variable.withInt(limit)],
      readsFrom: {journalEntries},
    ).get();

    return results.map((row) => JournalEntry(
      id: row.read<int>('id'),
      date: row.read<DateTime>('date'),
      title: row.read<String>('title'),
      content: row.read<String>('content'),
      mood: row.readNullable<String>('mood'),
      tags: row.readNullable<String>('tags'),
      summary: row.readNullable<String>('summary'),
      isAutoGenerated: row.read<bool>('is_auto_generated'),
      isEdited: row.read<bool>('is_edited'),
      createdAt: row.read<DateTime>('created_at'),
      updatedAt: row.read<DateTime>('updated_at'),
    )).toList();
  }

  // Rebuild the FTS index (useful after bulk imports)
  Future<void> rebuildSearchIndex() async {
    await customStatement("INSERT INTO journal_search(journal_search) VALUES('rebuild')");
  }

  // Journal Activities Methods
  Future<int> insertJournalActivity(JournalActivitiesCompanion activity) {
    return into(journalActivities).insert(activity);
  }

  Future<List<JournalActivity>> getActivitiesForEntry(int journalEntryId) {
    return (select(journalActivities)
          ..where((tbl) => tbl.journalEntryId.equals(journalEntryId))
          ..orderBy([(tbl) => OrderingTerm.asc(tbl.timestamp)]))
        .get();
  }

  Stream<List<JournalActivity>> watchActivitiesForEntry(int journalEntryId) {
    return (select(journalActivities)
          ..where((tbl) => tbl.journalEntryId.equals(journalEntryId))
          ..orderBy([(tbl) => OrderingTerm.asc(tbl.timestamp)]))
        .watch();
  }

  // Get activities for a specific date by first getting the journal entry
  Future<List<JournalActivity>> getActivitiesForDate(DateTime date) async {
    final journalEntry = await getJournalEntryForDate(date);
    if (journalEntry == null) {
      return [];
    }
    return getActivitiesForEntry(journalEntry.id);
  }

  // Watch activities for a specific date
  Stream<List<JournalActivity>> watchActivitiesForDate(DateTime date) async* {
    final journalEntry = await getJournalEntryForDate(date);
    if (journalEntry == null) {
      yield [];
      return;
    }
    yield* watchActivitiesForEntry(journalEntry.id);
  }

  // Journal Templates Methods
  Future<int> insertJournalTemplate(JournalTemplatesCompanion template) {
    return into(journalTemplates).insert(template);
  }

  Stream<List<JournalTemplate>> watchActiveTemplates() {
    return (select(journalTemplates)
          ..where((tbl) => tbl.isActive.equals(true))
          ..orderBy([(tbl) => OrderingTerm.desc(tbl.usageCount)]))
        .watch();
  }

  Future<void> incrementTemplateUsage(int templateId) async {
    await (update(journalTemplates)
          ..where((tbl) => tbl.id.equals(templateId)))
        .write(JournalTemplatesCompanion(
          usageCount: Value(1), // This will increment by 1
          lastUsedAt: Value(DateTime.now()),
        ));
  }

  // Statistics Methods
  Future<Map<String, int>> getJournalStatistics() async {
    final totalEntries = await (selectOnly(journalEntries)
          ..addColumns([journalEntries.id.count()]))
        .getSingle();

    final autoGenerated = await (selectOnly(journalEntries)
          ..addColumns([journalEntries.id.count()])
          ..where(journalEntries.isAutoGenerated.equals(true)))
        .getSingle();

    final edited = await (selectOnly(journalEntries)
          ..addColumns([journalEntries.id.count()])
          ..where(journalEntries.isEdited.equals(true)))
        .getSingle();

    final thisMonth = DateTime.now();
    final startOfMonth = DateTime(thisMonth.year, thisMonth.month, 1);
    final entriesThisMonth = await (selectOnly(journalEntries)
          ..addColumns([journalEntries.id.count()])
          ..where(journalEntries.date.isBiggerOrEqualValue(startOfMonth)))
        .getSingle();

    return {
      'total_entries': totalEntries.read(journalEntries.id.count()) ?? 0,
      'auto_generated': autoGenerated.read(journalEntries.id.count()) ?? 0,
      'user_edited': edited.read(journalEntries.id.count()) ?? 0,
      'this_month': entriesThisMonth.read(journalEntries.id.count()) ?? 0,
    };
  }

  // Data cleanup methods
  Future<void> cleanupOldEntries({
    Duration retentionPeriod = const Duration(days: 365),
  }) async {
    final cutoff = DateTime.now().subtract(retentionPeriod);

    await (delete(journalEntries)
          ..where((tbl) => tbl.date.isSmallerThanValue(cutoff)))
        .go();
  }

  // Helper method to create FTS5 triggers after tables exist
  Future<void> _createSearchTriggers() async {
    // Trigger to insert into FTS table when a new journal entry is created
    await customStatement('''
      CREATE TRIGGER IF NOT EXISTS journal_search_insert
      AFTER INSERT ON journal_entries
      BEGIN
        INSERT INTO journal_search(entry_id, title, content, mood, tags, summary)
        VALUES (new.id, new.title, new.content, new.mood, new.tags, new.summary);
      END;
    ''');

    // Trigger to update FTS table when a journal entry is updated
    await customStatement('''
      CREATE TRIGGER IF NOT EXISTS journal_search_update
      AFTER UPDATE ON journal_entries
      BEGIN
        UPDATE journal_search
        SET title = new.title,
            content = new.content,
            mood = new.mood,
            tags = new.tags,
            summary = new.summary
        WHERE entry_id = new.id;
      END;
    ''');

    // Trigger to delete from FTS table when a journal entry is deleted
    await customStatement('''
      CREATE TRIGGER IF NOT EXISTS journal_search_delete
      AFTER DELETE ON journal_entries
      BEGIN
        DELETE FROM journal_search WHERE entry_id = old.id;
      END;
    ''');
  }

  // Migration and schema updates
  @override
  MigrationStrategy get migration => MigrationStrategy(
        onCreate: (Migrator m) async {
          await m.createAll();

          // Create indices for better performance
          await customStatement('''
            CREATE INDEX IF NOT EXISTS idx_journal_entries_date ON journal_entries(date DESC);
          ''');
          await customStatement('''
            CREATE INDEX IF NOT EXISTS idx_journal_entries_created_at ON journal_entries(created_at DESC);
          ''');
          await customStatement('''
            CREATE INDEX IF NOT EXISTS idx_journal_activities_entry_timestamp ON journal_activities(journal_entry_id, timestamp);
          ''');
          await customStatement('''
            CREATE INDEX IF NOT EXISTS idx_journal_templates_active_usage ON journal_templates(is_active, usage_count DESC);
          ''');

          // Create FTS5 triggers after all tables exist
          await _createSearchTriggers();

          // Populate FTS5 index with existing data
          await customStatement('''
            INSERT INTO journal_search(entry_id, title, content, mood, tags, summary)
            SELECT id, title, content, mood, tags, summary
            FROM journal_entries;
          ''');
        },
        onUpgrade: (Migrator m, int from, int to) async {
          if (from < 2) {
            // Create FTS5 virtual table and triggers
            await m.createAll();

            // Create FTS5 triggers after all tables exist
            await _createSearchTriggers();

            // Populate FTS5 index with existing data
            await customStatement('''
              INSERT INTO journal_search(entry_id, title, content, mood, tags, summary)
              SELECT id, title, content, mood, tags, summary
              FROM journal_entries
              WHERE NOT EXISTS (
                SELECT 1 FROM journal_search WHERE entry_id = journal_entries.id
              );
            ''');
          }
        },
      );
}