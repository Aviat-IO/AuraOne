import 'package:drift/drift.dart';
import 'package:drift_flutter/drift_flutter.dart';
import 'package:flutter/foundation.dart';
import '../utils/date_utils.dart';

part 'journal_database.g.dart';

// Table for storing daily journal entries
class JournalEntries extends Table {
  IntColumn get id => integer().autoIncrement()();
  DateTimeColumn get date => dateTime()(); // Date of the journal entry (without time)
  TextColumn get title => text()();
  TextColumn get content => text()();
  TextColumn get mood => text().nullable()(); // Overall mood/sentiment
  TextColumn get tags => text().nullable()(); // JSON array of tags
  TextColumn get summary => text().nullable()(); // AI-generated summary
  TextColumn get originalAiSummary => text().nullable()(); // Original AI summary (for edit detection)
  TextColumn get summaryHash => text().nullable()(); // SHA-256 hash of original AI summary
  BoolColumn get summaryWasEdited => boolean().withDefault(const Constant(false))(); // User edited summary
  BoolColumn get isAutoGenerated => boolean().withDefault(const Constant(true))(); // Auto vs user created
  BoolColumn get isEdited => boolean().withDefault(const Constant(false))(); // User has edited
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
  DateTimeColumn get updatedAt => dateTime().withDefault(currentDateAndTime)();

  @override
  List<Set<Column>> get uniqueKeys => [
    {date}, // One entry per date
  ];
}

// Table for journal entry activities/events
class JournalActivities extends Table {
  IntColumn get id => integer().autoIncrement()();
  IntColumn get journalEntryId => integer().references(JournalEntries, #id, onDelete: KeyAction.cascade)();
  TextColumn get activityType => text()(); // 'location', 'photo', 'movement', 'calendar', 'manual'
  TextColumn get description => text()();
  TextColumn get metadata => text().nullable()(); // JSON with activity-specific data
  DateTimeColumn get timestamp => dateTime()();
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
}

// Table for user-defined journal templates
class JournalTemplates extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get name => text()();
  TextColumn get description => text().nullable()();
  TextColumn get prompt => text()(); // Template text with placeholders
  BoolColumn get isActive => boolean().withDefault(const Constant(true))();
  IntColumn get usageCount => integer().withDefault(const Constant(0))();
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
  DateTimeColumn get lastUsedAt => dateTime().nullable()();
}

@DriftDatabase(
  tables: [
    JournalEntries,
    JournalActivities,
    JournalTemplates,
  ],
  include: {'search_tables.drift'},
)
class JournalDatabase extends _$JournalDatabase {
  JournalDatabase() : super(_openConnection());

  // Constructor for testing with custom executor
  JournalDatabase.forTesting(QueryExecutor e) : super(e);

  @override
  int get schemaVersion => 3;

  static QueryExecutor _openConnection() {
    return driftDatabase(name: 'journal_database');
  }

  // Journal Entries Methods
  Future<int> insertJournalEntry(JournalEntriesCompanion entry) {
    return into(journalEntries).insert(entry, mode: InsertMode.insertOrReplace);
  }

  Future<bool> updateJournalEntry(JournalEntriesCompanion entry) async {
    final updatedRows = await (update(journalEntries)
          ..where((tbl) => tbl.id.equals(entry.id.value)))
        .write(entry);
    return updatedRows > 0;
  }

  Future<int> deleteJournalEntry(int id) {
    return (delete(journalEntries)..where((tbl) => tbl.id.equals(id))).go();
  }

  /// Update journal entry summary with edit protection
  ///
  /// Stores the original AI summary and hash for edit detection.
  /// Set summaryWasEdited=true to mark as user-edited.
  Future<bool> updateJournalSummary({
    required int id,
    required String summary,
    String? originalAiSummary,
    String? summaryHash,
    bool summaryWasEdited = false,
  }) async {
    final updatedRows = await (update(journalEntries)
          ..where((tbl) => tbl.id.equals(id)))
        .write(JournalEntriesCompanion(
          summary: Value(summary),
          originalAiSummary: Value(originalAiSummary),
          summaryHash: Value(summaryHash),
          summaryWasEdited: Value(summaryWasEdited),
          updatedAt: Value(DateTime.now()),
        ));
    return updatedRows > 0;
  }

  /// Mark journal entry summary as edited by user
  Future<bool> markSummaryAsEdited(int id) async {
    final updatedRows = await (update(journalEntries)
          ..where((tbl) => tbl.id.equals(id)))
        .write(JournalEntriesCompanion(
          summaryWasEdited: const Value(true),
          updatedAt: Value(DateTime.now()),
        ));
    return updatedRows > 0;
  }

  Future<JournalEntry?> getJournalEntryForDate(DateTime date) async {
    // Convert local date to UTC for database query
    final utcDate = DateTimeUtils.localDateToUtc(date);
    // Strip time component for date-only comparison
    final dateOnly = DateTime(utcDate.year, utcDate.month, utcDate.day);
    return await (select(journalEntries)
          ..where((tbl) => tbl.date.equals(dateOnly)))
        .getSingleOrNull();
  }

  Stream<JournalEntry?> watchJournalEntryForDate(DateTime date) {
    // Convert local date to UTC for database query
    final utcDate = DateTimeUtils.localDateToUtc(date);
    // Strip time component for date-only comparison
    final dateOnly = DateTime(utcDate.year, utcDate.month, utcDate.day);
    return (select(journalEntries)
          ..where((tbl) => tbl.date.equals(dateOnly)))
        .watchSingleOrNull();
  }

  Stream<List<JournalEntry>> watchRecentJournalEntries({
    int limit = 30,
  }) {
    return (select(journalEntries)
          ..orderBy([(tbl) => OrderingTerm.desc(tbl.date)])
          ..limit(limit))
        .watch();
  }

  Future<List<JournalEntry>> getJournalEntriesBetween(
    DateTime startDate,
    DateTime endDate,
  ) {
    // Convert local dates to UTC for database query
    final startUtc = DateTimeUtils.localDateToUtc(startDate);
    final endUtc = DateTimeUtils.localDateToUtc(endDate);
    final start = DateTime(startUtc.year, startUtc.month, startUtc.day);
    final end = DateTime(endUtc.year, endUtc.month, endUtc.day);

    return (select(journalEntries)
          ..where((tbl) => tbl.date.isBetweenValues(start, end))
          ..orderBy([(tbl) => OrderingTerm.asc(tbl.date)]))
        .get();
  }

  Future<JournalEntry?> getLatestJournalEntry() async {
    return await (select(journalEntries)
          ..orderBy([(tbl) => OrderingTerm.desc(tbl.date)])
          ..limit(1))
        .getSingleOrNull();
  }

  Future<List<JournalEntry>> searchJournalEntries(String query) {
    final lowerQuery = query.toLowerCase();
    return (select(journalEntries)
          ..where((tbl) =>
              tbl.title.lower().contains(lowerQuery) |
              tbl.content.lower().contains(lowerQuery))
          ..orderBy([(tbl) => OrderingTerm.desc(tbl.date)]))
        .get();
  }

  // FTS5-based search for journal entries
  Future<List<JournalEntry>> searchJournalEntriesFts(String query, {int limit = 50}) async {
    final results = await customSelect(
      '''
      SELECT
        je.id,
        je.date,
        je.title,
        je.content,
        je.mood,
        je.tags,
        je.summary,
        je.original_ai_summary,
        je.summary_hash,
        je.summary_was_edited,
        je.is_auto_generated,
        je.is_edited,
        je.created_at,
        je.updated_at,
        bm25(journal_search) as rank,
        snippet(journal_search, 1, '[', ']', '...', 32) as title_snippet,
        snippet(journal_search, 2, '[', ']', '...', 64) as content_snippet
      FROM journal_search js
      JOIN journal_entries je ON js.entry_id = je.id
      WHERE journal_search MATCH ?
      ORDER BY rank
      LIMIT ?
      ''',
      variables: [Variable.withString(query), Variable.withInt(limit)],
      readsFrom: {journalEntries},
    ).get();

    return results.map((row) => JournalEntry(
      id: row.read<int>('id'),
      date: row.read<DateTime>('date'),
      title: row.read<String>('title'),
      content: row.read<String>('content'),
      mood: row.readNullable<String>('mood'),
      tags: row.readNullable<String>('tags'),
      summary: row.readNullable<String>('summary'),
      originalAiSummary: row.readNullable<String>('original_ai_summary'),
      summaryHash: row.readNullable<String>('summary_hash'),
      summaryWasEdited: row.read<bool>('summary_was_edited'),
      isAutoGenerated: row.read<bool>('is_auto_generated'),
      isEdited: row.read<bool>('is_edited'),
      createdAt: row.read<DateTime>('created_at'),
      updatedAt: row.read<DateTime>('updated_at'),
    )).toList();
  }

  // Rebuild the FTS index (useful after bulk imports)
  Future<void> rebuildSearchIndex() async {
    await customStatement("INSERT INTO journal_search(journal_search) VALUES('rebuild')");
  }

  // Journal Activities Methods
  Future<int> insertJournalActivity(JournalActivitiesCompanion activity) {
    return into(journalActivities).insert(activity);
  }

  Future<List<JournalActivity>> getActivitiesForEntry(int journalEntryId) {
    return (select(journalActivities)
          ..where((tbl) => tbl.journalEntryId.equals(journalEntryId))
          ..orderBy([(tbl) => OrderingTerm.asc(tbl.timestamp)]))
        .get();
  }

  Stream<List<JournalActivity>> watchActivitiesForEntry(int journalEntryId) {
    return (select(journalActivities)
          ..where((tbl) => tbl.journalEntryId.equals(journalEntryId))
          ..orderBy([(tbl) => OrderingTerm.asc(tbl.timestamp)]))
        .watch();
  }

  // Get activities for a specific date by first getting the journal entry
  Future<List<JournalActivity>> getActivitiesForDate(DateTime date) async {
    final journalEntry = await getJournalEntryForDate(date);
    if (journalEntry == null) {
      return [];
    }
    return getActivitiesForEntry(journalEntry.id);
  }

  // Watch activities for a specific date
  Stream<List<JournalActivity>> watchActivitiesForDate(DateTime date) async* {
    final journalEntry = await getJournalEntryForDate(date);
    if (journalEntry == null) {
      yield [];
      return;
    }
    yield* watchActivitiesForEntry(journalEntry.id);
  }

  // Journal Templates Methods
  Future<int> insertJournalTemplate(JournalTemplatesCompanion template) {
    return into(journalTemplates).insert(template);
  }

  Stream<List<JournalTemplate>> watchActiveTemplates() {
    return (select(journalTemplates)
          ..where((tbl) => tbl.isActive.equals(true))
          ..orderBy([(tbl) => OrderingTerm.desc(tbl.usageCount)]))
        .watch();
  }

  Future<void> incrementTemplateUsage(int templateId) async {
    await (update(journalTemplates)
          ..where((tbl) => tbl.id.equals(templateId)))
        .write(JournalTemplatesCompanion(
          usageCount: Value(1), // This will increment by 1
          lastUsedAt: Value(DateTime.now()),
        ));
  }

  // Statistics Methods
  Future<Map<String, int>> getJournalStatistics() async {
    final totalEntries = await (selectOnly(journalEntries)
          ..addColumns([journalEntries.id.count()]))
        .getSingle();

    final autoGenerated = await (selectOnly(journalEntries)
          ..addColumns([journalEntries.id.count()])
          ..where(journalEntries.isAutoGenerated.equals(true)))
        .getSingle();

    final edited = await (selectOnly(journalEntries)
          ..addColumns([journalEntries.id.count()])
          ..where(journalEntries.isEdited.equals(true)))
        .getSingle();

    final thisMonth = DateTime.now();
    final startOfMonth = DateTime(thisMonth.year, thisMonth.month, 1);
    final entriesThisMonth = await (selectOnly(journalEntries)
          ..addColumns([journalEntries.id.count()])
          ..where(journalEntries.date.isBiggerOrEqualValue(startOfMonth)))
        .getSingle();

    return {
      'total_entries': totalEntries.read(journalEntries.id.count()) ?? 0,
      'auto_generated': autoGenerated.read(journalEntries.id.count()) ?? 0,
      'user_edited': edited.read(journalEntries.id.count()) ?? 0,
      'this_month': entriesThisMonth.read(journalEntries.id.count()) ?? 0,
    };
  }

  // Data cleanup methods
  Future<void> cleanupOldEntries({
    Duration retentionPeriod = const Duration(days: 365),
  }) async {
    final cutoff = DateTime.now().subtract(retentionPeriod);

    await (delete(journalEntries)
          ..where((tbl) => tbl.date.isSmallerThanValue(cutoff)))
        .go();
  }

  // Helper method to create FTS5 triggers after tables exist
  Future<void> _createSearchTriggers() async {
    // Trigger to insert into FTS table when a new journal entry is created
    await customStatement('''
      CREATE TRIGGER IF NOT EXISTS journal_search_insert
      AFTER INSERT ON journal_entries
      BEGIN
        INSERT INTO journal_search(entry_id, title, content, mood, tags, summary)
        VALUES (new.id, new.title, new.content, new.mood, new.tags, new.summary);
      END;
    ''');

    // Trigger to update FTS table when a journal entry is updated
    await customStatement('''
      CREATE TRIGGER IF NOT EXISTS journal_search_update
      AFTER UPDATE ON journal_entries
      BEGIN
        UPDATE journal_search
        SET title = new.title,
            content = new.content,
            mood = new.mood,
            tags = new.tags,
            summary = new.summary
        WHERE entry_id = new.id;
      END;
    ''');

    // Trigger to delete from FTS table when a journal entry is deleted
    await customStatement('''
      CREATE TRIGGER IF NOT EXISTS journal_search_delete
      AFTER DELETE ON journal_entries
      BEGIN
        DELETE FROM journal_search WHERE entry_id = old.id;
      END;
    ''');
  }

  // Migration and schema updates
  @override
  MigrationStrategy get migration => MigrationStrategy(
        beforeOpen: (details) async {
          // Handle database version mismatches gracefully
          if (details.wasCreated) {
            // Database was just created, no issues
            return;
          }

          // Check if we're dealing with a version mismatch
          if (details.versionBefore != null && details.versionNow != details.versionBefore) {
            debugPrint('Journal database migration: v${details.versionBefore} -> v${details.versionNow}');
          }
        },
        onCreate: (Migrator m) async {
          try {
            await m.createAll();
          } catch (e) {
            // If createAll fails, it might be because tables already exist from a previous installation
            debugPrint('Warning: Could not create all tables (may already exist): $e');
            // Try to continue anyway - the app should still work
          }

          // Create indices for better performance
          await customStatement('''
            CREATE INDEX IF NOT EXISTS idx_journal_entries_date ON journal_entries(date DESC);
          ''');
          await customStatement('''
            CREATE INDEX IF NOT EXISTS idx_journal_entries_created_at ON journal_entries(created_at DESC);
          ''');
          await customStatement('''
            CREATE INDEX IF NOT EXISTS idx_journal_activities_entry_timestamp ON journal_activities(journal_entry_id, timestamp);
          ''');
          await customStatement('''
            CREATE INDEX IF NOT EXISTS idx_journal_templates_active_usage ON journal_templates(is_active, usage_count DESC);
          ''');

          // Create FTS5 triggers after all tables exist
          await _createSearchTriggers();

          // Populate FTS5 index with existing data
          await customStatement('''
            INSERT INTO journal_search(entry_id, title, content, mood, tags, summary)
            SELECT id, title, content, mood, tags, summary
            FROM journal_entries;
          ''');
        },
        onUpgrade: (Migrator m, int from, int to) async {
          if (from < 2) {
            // Wrap entire migration in try-catch to prevent crashes
            try {
              // Check if FTS5 search table exists and create if it doesn't
              bool searchTableExists = false;
              try {
                await customSelect('SELECT COUNT(*) FROM journal_search').getSingle();
                searchTableExists = true;
              } catch (e) {
                // Table doesn't exist, need to create it
                searchTableExists = false;
              }

              if (!searchTableExists) {
                // Create only the FTS5 virtual table
                await customStatement('''
                  CREATE VIRTUAL TABLE IF NOT EXISTS journal_search USING fts5(
                    entry_id UNINDEXED,
                    title,
                    content,
                    mood,
                    tags,
                    summary,
                    tokenize = 'porter unicode61'
                  );
                ''');
              }

              // Try to create triggers, but don't fail if they already exist
              try {
                await _createSearchTriggers();
              } catch (e) {
                debugPrint('Note: Could not create search triggers (may already exist): $e');
              }

              // Populate FTS5 index with existing data (safely)
              try {
                await customStatement('''
                  INSERT INTO journal_search(entry_id, title, content, mood, tags, summary)
                  SELECT id, title, content, mood, tags, summary
                  FROM journal_entries
                  WHERE NOT EXISTS (
                    SELECT 1 FROM journal_search WHERE entry_id = journal_entries.id
                  );
                ''');
              } catch (e) {
                // If population fails, log but don't crash
                debugPrint('Warning: Could not populate FTS5 index during migration: $e');
              }
            } catch (e) {
              // Log the error but don't crash the app
              debugPrint('Error during journal database migration from v$from to v$to: $e');
              // The app can still function without FTS5 search
            }
          }

          if (from < 3) {
            // Add user edit protection columns for AI summaries
            try {
              await customStatement('''
                ALTER TABLE journal_entries ADD COLUMN original_ai_summary TEXT;
              ''');
            } catch (e) {
              debugPrint('Note: Could not add original_ai_summary column (may already exist): $e');
            }

            try {
              await customStatement('''
                ALTER TABLE journal_entries ADD COLUMN summary_hash TEXT;
              ''');
            } catch (e) {
              debugPrint('Note: Could not add summary_hash column (may already exist): $e');
            }

            try {
              await customStatement('''
                ALTER TABLE journal_entries ADD COLUMN summary_was_edited INTEGER NOT NULL DEFAULT 0;
              ''');
            } catch (e) {
              debugPrint('Note: Could not add summary_was_edited column (may already exist): $e');
            }

            debugPrint('Journal database migrated to v3: Added user edit protection for summaries');
          }
        },
      );
}