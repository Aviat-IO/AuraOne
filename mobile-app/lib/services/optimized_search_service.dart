import 'package:drift/drift.dart';
import '../database/journal_database.dart';
import '../services/enhanced_search_service.dart';

class OptimizedSearchService {
  /// Search journal entries using SQLite FTS5
  ///
  /// FTS5 provides:
  /// - Automatic stemming (victory matches victories)
  /// - BM25 ranking for relevance scoring
  /// - Snippet generation with search term highlighting
  /// - Phrase search with quotes
  /// - Prefix search with wildcards
  ///
  Future<List<JournalEntrySearchResult>> searchJournalEntries(
    JournalDatabase database,
    String query,
  ) async {
    if (query.trim().isEmpty) return [];

    // Prepare the search query for FTS5
    // Split by whitespace and add prefix search for each word
    final searchTerms = query
        .trim()
        .split(RegExp(r'\s+'))
        .where((word) => word.isNotEmpty)
        .map((word) => '"$word"*')  // Prefix search for each word
        .join(' OR ');

    try {
      // Use customSelect to execute the FTS5 query
      final results = await database.customSelect(
        '''
        SELECT
          je.id,
          je.date,
          je.title,
          je.content,
          je.mood,
          je.tags,
          je.summary,
          je.is_auto_generated,
          je.is_edited,
          je.created_at,
          je.updated_at,
          bm25(journal_search) as rank,
          snippet(journal_search, 1, '[', ']', '...', 32) as title_snippet,
          snippet(journal_search, 2, '[', ']', '...', 64) as content_snippet
        FROM journal_search js
        JOIN journal_entries je ON js.entry_id = je.id
        WHERE journal_search MATCH ?
        ORDER BY rank
        LIMIT 50
        ''',
        variables: [Variable.withString(searchTerms)],
        readsFrom: {database.journalEntries},
      ).get();

      // Convert results to JournalEntrySearchResult
      return results.map((row) {
        // Create JournalEntry from row data
        final entry = JournalEntry(
          id: row.read<int>('id'),
          date: row.read<DateTime>('date'),
          title: row.read<String>('title'),
          content: row.read<String>('content'),
          mood: row.readNullable<String>('mood'),
          tags: row.readNullable<String>('tags'),
          summary: row.readNullable<String>('summary'),
          isAutoGenerated: row.read<bool>('is_auto_generated'),
          isEdited: row.read<bool>('is_edited'),
          createdAt: row.read<DateTime>('created_at'),
          updatedAt: row.read<DateTime>('updated_at'),
        );

        // BM25 returns negative scores, convert to positive percentage
        final bm25Score = row.read<double>('rank');
        final relevanceScore = _normalizeScore(-bm25Score);

        // Extract matched terms from the snippets
        final titleSnippet = row.readNullable<String>('title_snippet') ?? '';
        final contentSnippet = row.readNullable<String>('content_snippet') ?? '';
        final matchedTerms = _extractMatchedTerms(titleSnippet, contentSnippet);

        return JournalEntrySearchResult(
          entry: entry,
          relevanceScore: relevanceScore,
          matchedTerms: matchedTerms.toList(),
        );
      }).toList();
    } catch (e) {
      // Fallback to basic search if FTS5 fails
      print('FTS5 search failed, falling back to basic search: $e');
      return _fallbackSearch(database, query);
    }
  }

  /// Normalize BM25 score to 0-100 range
  double _normalizeScore(double bm25Score) {
    // BM25 scores typically range from 0 to ~10
    // Convert to 0-100 percentage
    if (bm25Score <= 0) return 0;
    if (bm25Score >= 10) return 100;
    return (bm25Score / 10) * 100;
  }

  /// Extract matched terms from FTS5 snippets
  Set<String> _extractMatchedTerms(String titleSnippet, String contentSnippet) {
    final matchedTerms = <String>{};

    // Extract terms between square brackets (our highlight markers)
    final regex = RegExp(r'\[([^\]]+)\]');

    for (final match in regex.allMatches(titleSnippet)) {
      final term = match.group(1);
      if (term != null && term.isNotEmpty) {
        matchedTerms.add(term.toLowerCase());
      }
    }

    for (final match in regex.allMatches(contentSnippet)) {
      final term = match.group(1);
      if (term != null && term.isNotEmpty) {
        matchedTerms.add(term.toLowerCase());
      }
    }

    return matchedTerms;
  }

  /// Fallback to basic database search if FTS5 is not available
  Future<List<JournalEntrySearchResult>> _fallbackSearch(
    JournalDatabase database,
    String query,
  ) async {
    final entries = await database.searchJournalEntries(query);

    // Convert to search results with basic scoring
    return entries.map((entry) {
      // Simple relevance scoring based on match count
      final lowerQuery = query.toLowerCase();
      final lowerTitle = entry.title.toLowerCase();
      final lowerContent = entry.content.toLowerCase();

      int matchCount = 0;
      if (lowerTitle.contains(lowerQuery)) matchCount += 2; // Title matches worth more
      if (lowerContent.contains(lowerQuery)) matchCount += 1;
      if (entry.tags?.toLowerCase().contains(lowerQuery) ?? false) matchCount += 1;
      if (entry.mood?.toLowerCase().contains(lowerQuery) ?? false) matchCount += 1;

      final relevanceScore = (matchCount / 5) * 100; // Normalize to 0-100

      return JournalEntrySearchResult(
        entry: entry,
        relevanceScore: relevanceScore,
        matchedTerms: [lowerQuery],
      );
    }).toList()
      ..sort((a, b) => b.relevanceScore.compareTo(a.relevanceScore));
  }

  /// Rebuild the FTS5 search index
  ///
  /// This should be called after bulk imports or if the index gets corrupted
  Future<void> rebuildSearchIndex(JournalDatabase database) async {
    try {
      await database.customStatement(
        "INSERT INTO journal_search(journal_search) VALUES('rebuild')"
      );
    } catch (e) {
      print('Failed to rebuild search index: $e');
    }
  }

  /// Initialize FTS5 index with existing data
  ///
  /// This ensures all existing journal entries are indexed
  Future<void> initializeSearchIndex(JournalDatabase database) async {
    try {
      // Clear existing index
      await database.customStatement('DELETE FROM journal_search');

      // Re-populate from journal_entries
      await database.customStatement('''
        INSERT INTO journal_search(entry_id, title, content, mood, tags, summary)
        SELECT id, title, content, mood, tags, summary
        FROM journal_entries
      ''');
    } catch (e) {
      print('Failed to initialize search index: $e');
    }
  }
}