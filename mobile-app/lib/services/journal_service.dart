import 'dart:async';
import 'dart:convert';

import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:drift/drift.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../database/journal_database.dart';
import '../database/dev_seed_data.dart';
import '../services/ai/hybrid_ai_service.dart';
import '../services/reverse_geocoding_service.dart';
import '../providers/database_provider.dart';
import '../providers/service_providers.dart';
import '../utils/logger.dart';

final _logger = AppLogger('JournalService');

// Journal database provider
final journalDatabaseProvider = Provider<JournalDatabase>((ref) {
  return JournalDatabase();
});

// Journal service provider
final journalServiceProvider = Provider<JournalService>((ref) {
  return JournalService(
    ref.watch(journalDatabaseProvider),
    ref.watch(databaseServiceProvider),
    ref.watch(aiServiceProvider),
    ref,
  );
});

class JournalService {
  final JournalDatabase _journalDb;
  final DatabaseService _databaseService;
  final HybridAIService _aiService;
  final Ref _ref;

  Timer? _dailyTimer;

  JournalService(this._journalDb, this._databaseService, this._aiService, this._ref);

  /// Initialize the service and start daily entry generation
  Future<void> initialize() async {
    _logger.info('Initializing Journal Service...');

    // In development mode, seed the database with test data if needed
    if (kDebugMode) {
      final shouldSeed = await DevSeedData.shouldSeedDatabase(_journalDb);
      if (shouldSeed) {
        _logger.info('Development mode: Seeding database with test data...');
        await DevSeedData.seedDatabase(_journalDb);
      } else {
        _logger.info('Development mode: Database already has data, skipping seed');
      }
    }

    // Check if today's entry exists, create if not
    await _ensureTodayEntry();

    // Set up daily timer to create entries at midnight
    _setupDailyTimer();

    _logger.info('Journal Service initialized');
  }

  /// Dispose resources
  void dispose() {
    _dailyTimer?.cancel();
    _journalDb.close();
  }

  /// Get or create today's journal entry
  Future<JournalEntry> getTodayEntry() async {
    final today = DateTime.now();
    final existingEntry = await _journalDb.getJournalEntryForDate(today);

    if (existingEntry != null) {
      return existingEntry;
    }

    return await createEntryForDate(today);
  }

  /// Get journal entry for specific date
  Future<JournalEntry?> getEntryForDate(DateTime date) async {
    return await _journalDb.getJournalEntryForDate(date);
  }

  /// Watch today's journal entry
  Stream<JournalEntry?> watchTodayEntry() {
    final today = DateTime.now();
    return _journalDb.watchJournalEntryForDate(today);
  }

  /// Watch journal entry for specific date
  Stream<JournalEntry?> watchEntryForDate(DateTime date) {
    return _journalDb.watchJournalEntryForDate(date);
  }

  /// Get recent journal entries
  Stream<List<JournalEntry>> watchRecentEntries({int limit = 30}) {
    return _journalDb.watchRecentJournalEntries(limit: limit);
  }

  /// Create a journal entry for specific date
  Future<JournalEntry> createEntryForDate(DateTime date) async {
    _logger.info('Creating journal entry for ${date.toIso8601String()}');

    try {
      // Gather rich context for AI generation
      final context = await _gatherRichContext(date);

      // Generate AI journal entry using rich context
      final aiEntry = await _aiService.generateJournalEntry(context);

      // Extract activities from the day
      final activities = await _extractActivitiesForDate(date);

      // Extract title from content (first line or generate one)
      final contentLines = aiEntry['content'].toString().split('\n');
      final title = contentLines.first.replaceAll(RegExp(r'^#+\s*'), '').trim();
      final actualTitle = title.isNotEmpty ? title : 'Daily Reflection - ${_formatDate(date)}';

      // Create the journal entry
      final entryId = await _journalDb.insertJournalEntry(
        JournalEntriesCompanion(
          date: Value(DateTime(date.year, date.month, date.day)),
          title: Value(actualTitle),
          content: Value(aiEntry['content'].toString()),
          summary: Value(aiEntry['summary'].toString()),
          isAutoGenerated: const Value(true),
          isEdited: const Value(false),
          createdAt: Value(DateTime.now()),
          updatedAt: Value(DateTime.now()),
        ),
      );

      // Add activities to the entry
      for (final activity in activities) {
        await _journalDb.insertJournalActivity(
          JournalActivitiesCompanion(
            journalEntryId: Value(entryId),
            activityType: Value(activity['type']),
            description: Value(activity['description']),
            metadata: Value(jsonEncode(activity['metadata'])),
            timestamp: Value(activity['timestamp']),
          ),
        );
      }

      final entry = await _journalDb.getJournalEntryForDate(date);
      _logger.info('Created journal entry with ID: $entryId');

      return entry!;
    } catch (e, stack) {
      _logger.error('Failed to create journal entry for ${date.toIso8601String()}', error: e, stackTrace: stack);

      // Create fallback entry
      await _journalDb.insertJournalEntry(
        JournalEntriesCompanion(
          date: Value(DateTime(date.year, date.month, date.day)),
          title: Value('Daily Reflection - ${_formatDate(date)}'),
          content: Value('Today was a new day with its own unique moments and experiences.'),
          summary: Value('A day of experiences and growth.'),
          isAutoGenerated: const Value(true),
          isEdited: const Value(false),
        ),
      );

      final fallbackEntry = await _journalDb.getJournalEntryForDate(date);
      return fallbackEntry!;
    }
  }

  /// Update journal entry (marks as edited)
  Future<bool> updateJournalEntry({
    required int id,
    String? title,
    String? content,
    String? summary,
  }) async {
    try {
      _logger.info('Updating journal entry $id with: title=${title?.substring(0, 30) ?? 'null'}, content_length=${content?.length ?? 0}');

      final result = await _journalDb.updateJournalEntry(
        JournalEntriesCompanion(
          id: Value(id),
          title: title != null ? Value(title) : const Value.absent(),
          content: content != null ? Value(content) : const Value.absent(),
          summary: summary != null ? Value(summary) : const Value.absent(),
          isEdited: const Value(true),
          updatedAt: Value(DateTime.now()),
        ),
      );

      _logger.info('Successfully updated journal entry $id: result=$result');
      return result;
    } catch (e, stack) {
      _logger.error('Failed to update journal entry: $id', error: e, stackTrace: stack);
      return false;
    }
  }

  /// Get journal statistics
  Future<Map<String, int>> getStatistics() async {
    return await _journalDb.getJournalStatistics();
  }

  /// Add a manual activity to the database
  Future<void> addManualActivity({
    required DateTime date,
    required String title,
    required String description,
    required DateTime timestamp,
    required String activityType,
  }) async {
    try {
      _logger.info('Adding manual activity: $title');

      // Get or create today's journal entry
      final entry = await getTodayEntry();

      // Add the activity
      // Combine title and description only if description is not empty
      final activityDescription = description.isEmpty
        ? title
        : '$title - $description';

      await _journalDb.insertJournalActivity(
        JournalActivitiesCompanion(
          journalEntryId: Value(entry.id),
          activityType: Value(activityType),
          description: Value(activityDescription),
          metadata: Value(jsonEncode({
            'manual': true,
            'user_created': true,
            'title': title,
          })),
          timestamp: Value(timestamp),
        ),
      );

      _logger.info('Successfully added manual activity: $title');
    } catch (e, stack) {
      _logger.error('Failed to add manual activity: $title', error: e, stackTrace: stack);
      rethrow;
    }
  }

  /// Update an event's details
  Future<void> updateEvent({
    required String eventId,
    required String title,
    required String description,
    required String notes,
    required DateTime timestamp,
  }) async {
    try {
      _logger.info('Updating event: $eventId');

      // For now, this creates a new manual activity since we don't have
      // a specific events table - this integrates with the existing activity system
      // Construct description based on what content is available
      String fullDescription = '';
      if (description.isNotEmpty && notes.isNotEmpty) {
        fullDescription = '$description\n\nNotes: $notes';
      } else if (description.isNotEmpty) {
        fullDescription = description;
      } else if (notes.isNotEmpty) {
        fullDescription = 'Notes: $notes';
      }

      await addManualActivity(
        date: DateTime(timestamp.year, timestamp.month, timestamp.day),
        title: title,
        description: fullDescription,
        timestamp: timestamp,
        activityType: 'manual',
      );

      _logger.info('Successfully updated event: $eventId');
    } catch (e, stack) {
      _logger.error('Failed to update event: $eventId', error: e, stackTrace: stack);
      rethrow;
    }
  }

  /// Update an event's notes
  Future<void> updateEventNotes({
    required String eventId,
    required String notes,
  }) async {
    try {
      _logger.info('Updating event notes: $eventId');

      // For now, create a note entry as a manual activity
      final now = DateTime.now();
      await addManualActivity(
        date: DateTime(now.year, now.month, now.day),
        title: 'Event Notes',
        description: notes,
        timestamp: now,
        activityType: 'manual',
      );

      _logger.info('Successfully updated event notes: $eventId');
    } catch (e, stack) {
      _logger.error('Failed to update event notes: $eventId', error: e, stackTrace: stack);
      rethrow;
    }
  }

  /// Generate AI reflection for a specific event
  Future<String> generateEventReflection({
    required dynamic event,
    String? existingNotes,
  }) async {
    try {
      _logger.info('Generating AI reflection for event: ${event.title}');

      // Prepare context for AI generation
      final context = {
        'event_title': event.title,
        'event_description': event.description,
        'event_type': event.type.toString(),
        'event_time': event.time.toIso8601String(),
        'existing_notes': existingNotes ?? '',
        'generation_type': 'event_reflection',
      };

      // Generate AI reflection using existing AI service
      final aiResult = await _aiService.generateJournalEntry(context);

      // Extract the content from the AI response
      final reflection = aiResult['content']?.toString() ??
        'This was a meaningful moment that deserves reflection. Consider what made it special, how it made you feel, and what you might learn from it.';

      _logger.info('Successfully generated AI reflection for event: ${event.title}');
      return reflection;
    } catch (e, stack) {
      _logger.error('Failed to generate AI reflection for event: ${event.title}', error: e, stackTrace: stack);

      // Return a fallback reflection
      return 'This was a meaningful moment in your day. Take a moment to reflect on what made it special, how it made you feel, and what insights you might gain from this experience.';
    }
  }

  /// Gather rich context for AI generation
  Future<Map<String, dynamic>> _gatherRichContext(DateTime date) async {
    final context = <String, dynamic>{
      'date': date.toIso8601String(),
    };

    final startOfDay = DateTime(date.year, date.month, date.day);
    final endOfDay = startOfDay.add(const Duration(days: 1));

    try {
      // Get photos with metadata
      final photos = <Map<String, dynamic>>[];
      final mediaDb = _ref.read(mediaDatabaseProvider);
      final mediaItems = await mediaDb.getMediaByDateRange(
        startDate: startOfDay,
        endDate: endOfDay,
        processedOnly: true,
      );

      for (final item in mediaItems) {
          final photoContext = <String, dynamic>{
            'id': item.id,
            'timestamp': item.createdDate.toIso8601String(),
            'fileName': item.fileName,
          };

          // Try to get location from metadata
          final locationMetadata = await mediaDb.getMetadataForMedia(
            item.id,
            'location'
          );

          if (locationMetadata.isNotEmpty) {
            double? latitude, longitude;
            for (final meta in locationMetadata) {
              if (meta.key == 'gps_latitude') {
                latitude = double.tryParse(meta.value);
              } else if (meta.key == 'gps_longitude') {
                longitude = double.tryParse(meta.value);
              }
            }

            if (latitude != null && longitude != null) {
              photoContext['latitude'] = latitude;
              photoContext['longitude'] = longitude;

              // Perform reverse geocoding if location names are enabled
              final prefs = await SharedPreferences.getInstance();
              final reverseGeocodingEnabled = prefs.getBool('reverseGeocodingEnabled') ?? false;
              if (reverseGeocodingEnabled) {
                final placeInfo = await ReverseGeocodingService.getPlaceInfo(
                  latitude: latitude,
                  longitude: longitude,
                );
                if (placeInfo != null) {
                  photoContext['location'] = placeInfo.displayName;
                }
              }
            }
          }

          photos.add(photoContext);
      }

      context['photos'] = photos;
      context['photosCount'] = photos.length;

      // Get calendar events
      final calendarEvents = <Map<String, dynamic>>[];
      try {
        final calendarService = _ref.read(calendarServiceProvider);
        final events = await calendarService.getEventsInRange(startOfDay, endOfDay);

        for (final event in events) {
          calendarEvents.add({
            'title': event.title,
            'description': event.description,
            'startTime': event.startDate.toIso8601String(),
            'endTime': event.endDate?.toIso8601String(),
            'location': event.location,
            'attendees': event.attendees,
            'isAllDay': event.isAllDay,
          });
        }
      } catch (e) {
        _logger.warning('Failed to get calendar events: $e');
      }

      context['calendarEvents'] = calendarEvents;

      // Get existing timeline activities from database
      // These are the activities shown in the timeline (manual entries, etc.)
      final timelineActivities = <Map<String, dynamic>>[];
      try {
        final activities = await _journalDb.getActivitiesForDate(date);

        for (final activity in activities) {
          // Skip the automatic placeholder entry
          if (activity.activityType == 'manual' &&
              activity.description == 'Personal reflections and thoughts') {
            continue;
          }

          // Parse metadata if available
          Map<String, dynamic>? metadata;
          if (activity.metadata != null) {
            try {
              metadata = jsonDecode(activity.metadata!);
            } catch (_) {
              metadata = null;
            }
          }

          // Extract title and description from the activity
          String title = activity.description;
          String description = '';

          // For manual entries, the description might be in format "Title - Description"
          if (activity.description.contains(' - ')) {
            final parts = activity.description.split(' - ');
            title = parts[0];
            description = parts.length > 1 ? parts.sublist(1).join(' - ') : '';
          }

          timelineActivities.add({
            'title': title,
            'description': description,
            'activityType': activity.activityType,
            'timestamp': activity.timestamp.toIso8601String(),
            'metadata': metadata,
          });
        }
      } catch (e) {
        _logger.warning('Failed to get timeline activities: $e');
      }

      // Merge timeline activities with calendar events for comprehensive event list
      final allEvents = [...calendarEvents, ...timelineActivities];
      context['calendarEvents'] = allEvents;
      context['timelineActivities'] = timelineActivities;

      // Get clustered location data
      final locationClusters = <Map<String, dynamic>>[];
      try {
        // Get location points for the day
        final locationPoints = await _databaseService.locationDb.getLocationPointsBetween(
          startOfDay,
          endOfDay,
        );

        if (locationPoints.isNotEmpty) {
          // Use a simple clustering algorithm to group nearby locations
          final clusters = _clusterLocations(locationPoints);

          for (final cluster in clusters) {
            final clusterContext = <String, dynamic>{
              'latitude': cluster['centerLat'],
              'longitude': cluster['centerLng'],
              'duration': cluster['durationMinutes'],
              'visitCount': cluster['visitCount'],
              'timeOfDay': _getTimeOfDay(cluster['averageTime'] as DateTime),
            };

            // Reverse geocode if enabled
            final prefs = await SharedPreferences.getInstance();
            final reverseGeocodingEnabled = prefs.getBool('reverseGeocodingEnabled') ?? false;
            if (reverseGeocodingEnabled) {
              final placeInfo = await ReverseGeocodingService.getPlaceInfo(
                latitude: cluster['centerLat'] as double,
                longitude: cluster['centerLng'] as double,
              );
              if (placeInfo != null) {
                clusterContext['name'] = placeInfo.displayName;
              }
            }

            locationClusters.add(clusterContext);
          }
        }
      } catch (e) {
        _logger.warning('Failed to get location clusters: $e');
      }

      context['locationClusters'] = locationClusters;
      context['locationsCount'] = locationClusters.length;

      // Get movement data
      final movements = <Map<String, dynamic>>[];
      try {
        final movementData = await _databaseService.locationDb.getMovementDataBetween(
          startOfDay,
          endOfDay,
        );

        int totalSteps = 0;
        double totalDistance = 0;
        int activeMinutes = 0;

        for (final movement in movementData) {
          // Estimate steps and distance from movement patterns
          final estimatedSteps = (movement.sampleCount * 2.5).round(); // Rough estimate
          final estimatedDistance = movement.sampleCount * 0.0008; // ~0.8m per sample

          totalSteps += estimatedSteps;
          totalDistance += estimatedDistance;

          if (movement.stillPercentage < 50) {
            activeMinutes += 5; // Each movement sample represents ~5 minutes
          }

          movements.add({
            'timestamp': movement.timestamp.toIso8601String(),
            'activityType': movement.state, // Use 'state' field instead of 'activityType'
            'stillPercentage': movement.stillPercentage,
            'steps': estimatedSteps,
            'distance': estimatedDistance,
            'activeMinutes': movement.stillPercentage < 50 ? 5 : 0,
          });
        }

        // Add aggregated movement data
        if (movements.isNotEmpty) {
          context['totalSteps'] = totalSteps;
          context['totalDistance'] = totalDistance;
          context['activeMinutes'] = activeMinutes;
        }
      } catch (e) {
        _logger.warning('Failed to get movement data: $e');
      }

      context['movements'] = movements;

      // Also maintain legacy format for backward compatibility
      context['locations'] = locationClusters.map((c) => {
        'latitude': c['latitude'],
        'longitude': c['longitude'],
        'name': c['name'],
      }).toList();

    } catch (e, stack) {
      _logger.error('Failed to gather rich context', error: e, stackTrace: stack);
    }

    return context;
  }

  /// Simple location clustering algorithm
  List<Map<String, dynamic>> _clusterLocations(List<dynamic> locationPoints) {
    if (locationPoints.isEmpty) return [];

    final clusters = <Map<String, dynamic>>[];
    final clusterRadius = 0.0005; // ~50 meters in degrees

    for (final point in locationPoints) {
      bool addedToCluster = false;

      for (final cluster in clusters) {
        final distance = _calculateDistance(
          cluster['centerLat'] as double,
          cluster['centerLng'] as double,
          point.latitude as double,
          point.longitude as double,
        );

        if (distance < clusterRadius) {
          // Add to existing cluster
          cluster['points'].add(point);
          cluster['endTime'] = point.timestamp;

          // Update center
          final points = cluster['points'] as List;
          double sumLat = 0, sumLng = 0;
          for (final p in points) {
            sumLat += p.latitude as double;
            sumLng += p.longitude as double;
          }
          cluster['centerLat'] = sumLat / points.length;
          cluster['centerLng'] = sumLng / points.length;

          addedToCluster = true;
          break;
        }
      }

      if (!addedToCluster) {
        // Create new cluster
        clusters.add({
          'points': [point],
          'centerLat': point.latitude,
          'centerLng': point.longitude,
          'startTime': point.timestamp,
          'endTime': point.timestamp,
          'visitCount': 1,
        });
      }
    }

    // Calculate duration and other metrics for each cluster
    for (final cluster in clusters) {
      final startTime = cluster['startTime'] as DateTime;
      final endTime = cluster['endTime'] as DateTime;
      final duration = endTime.difference(startTime);

      cluster['durationMinutes'] = duration.inMinutes;
      cluster['averageTime'] = startTime.add(Duration(minutes: duration.inMinutes ~/ 2));

      // Remove the points array to reduce memory
      cluster.remove('points');
    }

    // Sort by duration (most significant places first)
    clusters.sort((a, b) =>
      (b['durationMinutes'] as int).compareTo(a['durationMinutes'] as int));

    return clusters;
  }

  /// Calculate distance between two coordinates (simple approximation)
  double _calculateDistance(double lat1, double lng1, double lat2, double lng2) {
    final dLat = lat2 - lat1;
    final dLng = lng2 - lng1;
    return (dLat * dLat + dLng * dLng).abs();
  }

  /// Get time of day description
  String _getTimeOfDay(DateTime time) {
    final hour = time.hour;
    if (hour < 6) return 'early morning';
    if (hour < 12) return 'morning';
    if (hour < 17) return 'afternoon';
    if (hour < 21) return 'evening';
    return 'night';
  }


  /// Extract activities for a specific date
  Future<List<Map<String, dynamic>>> _extractActivitiesForDate(DateTime date) async {
    final activities = <Map<String, dynamic>>[];
    final startOfDay = DateTime(date.year, date.month, date.day);
    final endOfDay = startOfDay.add(const Duration(days: 1));

    try {
      // Get location data
      final locationPoints = await _databaseService.locationDb.getLocationPointsBetween(startOfDay, endOfDay);
      if (locationPoints.isNotEmpty) {
        activities.add({
          'type': 'location',
          'description': 'Visited ${locationPoints.length} locations throughout the day',
          'metadata': {
            'point_count': locationPoints.length,
            'first_location': {
              'lat': locationPoints.first.latitude,
              'lon': locationPoints.first.longitude,
            },
            'last_location': {
              'lat': locationPoints.last.latitude,
              'lon': locationPoints.last.longitude,
            },
          },
          'timestamp': locationPoints.first.timestamp,
        });
      }

      // Get movement data
      final movementData = await _databaseService.locationDb.getMovementDataBetween(startOfDay, endOfDay);
      if (movementData.isNotEmpty) {
        final totalSamples = movementData.fold(0, (sum, data) => sum + data.sampleCount);
        final averageStillTime = movementData.fold(0.0, (sum, data) => sum + data.stillPercentage) / movementData.length;

        activities.add({
          'type': 'movement',
          'description': 'Movement patterns recorded throughout the day',
          'metadata': {
            'total_samples': totalSamples,
            'average_still_percentage': averageStillTime,
            'activity_changes': movementData.length,
          },
          'timestamp': movementData.first.timestamp,
        });
      }

      // Get media from the day
      final mediaDb = _ref.read(mediaDatabaseProvider);
      final mediaItems = await mediaDb.getMediaByDateRange(
        startDate: startOfDay,
        endDate: endOfDay,
        processedOnly: false,
      );
      if (mediaItems.isNotEmpty) {
        activities.add({
          'type': 'photo',
          'description': 'Captured ${mediaItems.length} photos and memories',
          'metadata': {
            'media_count': mediaItems.length,
            'first_photo': mediaItems.first.fileName,
          },
          'timestamp': mediaItems.first.createdDate,
        });
      }

    } catch (e, stack) {
      _logger.warning('Failed to extract some activities for ${date.toIso8601String()}', error: e, stackTrace: stack);
    }

    return activities;
  }

  /// Setup daily timer to create entries
  void _setupDailyTimer() {
    final now = DateTime.now();
    final tomorrow = DateTime(now.year, now.month, now.day + 1);
    final timeUntilMidnight = tomorrow.difference(now);

    _logger.info('Setting up daily timer - next entry in ${timeUntilMidnight.inHours}h ${timeUntilMidnight.inMinutes % 60}m');

    // Create timer for tomorrow's midnight
    _dailyTimer = Timer(timeUntilMidnight, () {
      _createDailyEntry();

      // Setup recurring daily timer
      _dailyTimer = Timer.periodic(const Duration(days: 1), (_) {
        _createDailyEntry();
      });
    });
  }

  /// Create daily entry automatically
  Future<void> _createDailyEntry() async {
    final yesterday = DateTime.now().subtract(const Duration(days: 1));
    _logger.info('Creating automatic daily entry for ${yesterday.toIso8601String()}');

    try {
      final existingEntry = await _journalDb.getJournalEntryForDate(yesterday);
      if (existingEntry == null) {
        await createEntryForDate(yesterday);
        _logger.info('Created automatic daily entry for ${yesterday.toIso8601String()}');
      } else {
        _logger.info('Daily entry already exists for ${yesterday.toIso8601String()}');
      }
    } catch (e, stack) {
      _logger.error('Failed to create automatic daily entry for ${yesterday.toIso8601String()}', error: e, stackTrace: stack);
    }
  }

  /// Ensure today's entry exists
  Future<void> _ensureTodayEntry() async {
    final today = DateTime.now();
    final existingEntry = await _journalDb.getJournalEntryForDate(today);

    if (existingEntry == null) {
      _logger.info('No entry found for today, creating one...');
      await createEntryForDate(today);
    } else {
      _logger.info('Today\'s entry already exists: ${existingEntry.title}');
    }
  }

  /// Format date for display
  String _formatDate(DateTime date) {
    final months = [
      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
    ];
    return '${months[date.month - 1]} ${date.day}, ${date.year}';
  }


}