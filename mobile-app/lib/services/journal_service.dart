import 'dart:async';
import 'dart:convert';

import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:drift/drift.dart';

import '../database/journal_database.dart';
import '../database/dev_seed_data.dart';
import '../services/ai/hybrid_ai_service.dart';
import '../providers/database_provider.dart';
import '../providers/service_providers.dart';
import '../utils/logger.dart';

final _logger = AppLogger('JournalService');

// Journal database provider
final journalDatabaseProvider = Provider<JournalDatabase>((ref) {
  return JournalDatabase();
});

// Journal service provider
final journalServiceProvider = Provider<JournalService>((ref) {
  return JournalService(
    ref.watch(journalDatabaseProvider),
    ref.watch(databaseServiceProvider),
    ref.watch(aiServiceProvider),
  );
});

class JournalService {
  final JournalDatabase _journalDb;
  final DatabaseService _databaseService;
  final HybridAIService _aiService;

  Timer? _dailyTimer;

  JournalService(this._journalDb, this._databaseService, this._aiService);

  /// Initialize the service and start daily entry generation
  Future<void> initialize() async {
    _logger.info('Initializing Journal Service...');

    // In development mode, seed the database with test data if needed
    if (kDebugMode) {
      final shouldSeed = await DevSeedData.shouldSeedDatabase(_journalDb);
      if (shouldSeed) {
        _logger.info('Development mode: Seeding database with test data...');
        await DevSeedData.seedDatabase(_journalDb);
      } else {
        _logger.info('Development mode: Database already has data, skipping seed');
      }
    }

    // Check if today's entry exists, create if not
    await _ensureTodayEntry();

    // Set up daily timer to create entries at midnight
    _setupDailyTimer();

    _logger.info('Journal Service initialized');
  }

  /// Dispose resources
  void dispose() {
    _dailyTimer?.cancel();
    _journalDb.close();
  }

  /// Get or create today's journal entry
  Future<JournalEntry> getTodayEntry() async {
    final today = DateTime.now();
    final existingEntry = await _journalDb.getJournalEntryForDate(today);

    if (existingEntry != null) {
      return existingEntry;
    }

    return await createEntryForDate(today);
  }

  /// Get journal entry for specific date
  Future<JournalEntry?> getEntryForDate(DateTime date) async {
    return await _journalDb.getJournalEntryForDate(date);
  }

  /// Watch today's journal entry
  Stream<JournalEntry?> watchTodayEntry() {
    final today = DateTime.now();
    return _journalDb.watchJournalEntryForDate(today);
  }

  /// Watch journal entry for specific date
  Stream<JournalEntry?> watchEntryForDate(DateTime date) {
    return _journalDb.watchJournalEntryForDate(date);
  }

  /// Get recent journal entries
  Stream<List<JournalEntry>> watchRecentEntries({int limit = 30}) {
    return _journalDb.watchRecentJournalEntries(limit: limit);
  }

  /// Create a journal entry for specific date
  Future<JournalEntry> createEntryForDate(DateTime date) async {
    _logger.info('Creating journal entry for ${date.toIso8601String()}');

    try {
      // Generate AI journal entry using existing AI service
      final aiEntry = await _aiService.generateJournalEntry({
        'date': date.toIso8601String(),
      });

      // Extract activities from the day
      final activities = await _extractActivitiesForDate(date);

      // Extract title from content (first line or generate one)
      final contentLines = aiEntry['content'].toString().split('\n');
      final title = contentLines.first.replaceAll(RegExp(r'^#+\s*'), '').trim();
      final actualTitle = title.isNotEmpty ? title : 'Daily Reflection - ${_formatDate(date)}';

      // Create the journal entry
      final entryId = await _journalDb.insertJournalEntry(
        JournalEntriesCompanion(
          date: Value(DateTime(date.year, date.month, date.day)),
          title: Value(actualTitle),
          content: Value(aiEntry['content'].toString()),
          summary: Value(aiEntry['summary'].toString()),
          isAutoGenerated: const Value(true),
          isEdited: const Value(false),
          createdAt: Value(DateTime.now()),
          updatedAt: Value(DateTime.now()),
        ),
      );

      // Add activities to the entry
      for (final activity in activities) {
        await _journalDb.insertJournalActivity(
          JournalActivitiesCompanion(
            journalEntryId: Value(entryId),
            activityType: Value(activity['type']),
            description: Value(activity['description']),
            metadata: Value(jsonEncode(activity['metadata'])),
            timestamp: Value(activity['timestamp']),
          ),
        );
      }

      final entry = await _journalDb.getJournalEntryForDate(date);
      _logger.info('Created journal entry with ID: $entryId');

      return entry!;
    } catch (e, stack) {
      _logger.error('Failed to create journal entry for ${date.toIso8601String()}', error: e, stackTrace: stack);

      // Create fallback entry
      await _journalDb.insertJournalEntry(
        JournalEntriesCompanion(
          date: Value(DateTime(date.year, date.month, date.day)),
          title: Value('Daily Reflection - ${_formatDate(date)}'),
          content: Value('Today was a new day with its own unique moments and experiences.'),
          summary: Value('A day of experiences and growth.'),
          isAutoGenerated: const Value(true),
          isEdited: const Value(false),
        ),
      );

      final fallbackEntry = await _journalDb.getJournalEntryForDate(date);
      return fallbackEntry!;
    }
  }

  /// Update journal entry (marks as edited)
  Future<bool> updateJournalEntry({
    required int id,
    String? title,
    String? content,
    String? summary,
  }) async {
    try {
      _logger.info('Updating journal entry $id with: title=${title?.substring(0, 30) ?? 'null'}, content_length=${content?.length ?? 0}');

      final result = await _journalDb.updateJournalEntry(
        JournalEntriesCompanion(
          id: Value(id),
          title: title != null ? Value(title) : const Value.absent(),
          content: content != null ? Value(content) : const Value.absent(),
          summary: summary != null ? Value(summary) : const Value.absent(),
          isEdited: const Value(true),
          updatedAt: Value(DateTime.now()),
        ),
      );

      _logger.info('Successfully updated journal entry $id: result=$result');
      return result;
    } catch (e, stack) {
      _logger.error('Failed to update journal entry: $id', error: e, stackTrace: stack);
      return false;
    }
  }

  /// Get journal statistics
  Future<Map<String, int>> getStatistics() async {
    return await _journalDb.getJournalStatistics();
  }

  /// Add a manual activity to the database
  Future<void> addManualActivity({
    required DateTime date,
    required String title,
    required String description,
    required DateTime timestamp,
    required String activityType,
  }) async {
    try {
      _logger.info('Adding manual activity: $title');

      // Get or create today's journal entry
      final entry = await getTodayEntry();

      // Add the activity
      await _journalDb.insertJournalActivity(
        JournalActivitiesCompanion(
          journalEntryId: Value(entry.id),
          activityType: Value(activityType),
          description: Value('$title - $description'),
          metadata: Value(jsonEncode({
            'manual': true,
            'user_created': true,
            'title': title,
          })),
          timestamp: Value(timestamp),
        ),
      );

      _logger.info('Successfully added manual activity: $title');
    } catch (e, stack) {
      _logger.error('Failed to add manual activity: $title', error: e, stackTrace: stack);
      rethrow;
    }
  }

  /// Update an event's details
  Future<void> updateEvent({
    required String eventId,
    required String title,
    required String description,
    required String notes,
    required DateTime timestamp,
  }) async {
    try {
      _logger.info('Updating event: $eventId');

      // For now, this creates a new manual activity since we don't have
      // a specific events table - this integrates with the existing activity system
      await addManualActivity(
        date: DateTime(timestamp.year, timestamp.month, timestamp.day),
        title: title,
        description: '$description\n\nNotes: $notes',
        timestamp: timestamp,
        activityType: 'manual',
      );

      _logger.info('Successfully updated event: $eventId');
    } catch (e, stack) {
      _logger.error('Failed to update event: $eventId', error: e, stackTrace: stack);
      rethrow;
    }
  }

  /// Update an event's notes
  Future<void> updateEventNotes({
    required String eventId,
    required String notes,
  }) async {
    try {
      _logger.info('Updating event notes: $eventId');

      // For now, create a note entry as a manual activity
      final now = DateTime.now();
      await addManualActivity(
        date: DateTime(now.year, now.month, now.day),
        title: 'Event Notes',
        description: notes,
        timestamp: now,
        activityType: 'manual',
      );

      _logger.info('Successfully updated event notes: $eventId');
    } catch (e, stack) {
      _logger.error('Failed to update event notes: $eventId', error: e, stackTrace: stack);
      rethrow;
    }
  }

  /// Generate AI reflection for a specific event
  Future<String> generateEventReflection({
    required dynamic event,
    String? existingNotes,
  }) async {
    try {
      _logger.info('Generating AI reflection for event: ${event.title}');

      // Prepare context for AI generation
      final context = {
        'event_title': event.title,
        'event_description': event.description,
        'event_type': event.type.toString(),
        'event_time': event.time.toIso8601String(),
        'existing_notes': existingNotes ?? '',
        'generation_type': 'event_reflection',
      };

      // Generate AI reflection using existing AI service
      final aiResult = await _aiService.generateJournalEntry(context);

      // Extract the content from the AI response
      final reflection = aiResult['content']?.toString() ??
        'This was a meaningful moment that deserves reflection. Consider what made it special, how it made you feel, and what you might learn from it.';

      _logger.info('Successfully generated AI reflection for event: ${event.title}');
      return reflection;
    } catch (e, stack) {
      _logger.error('Failed to generate AI reflection for event: ${event.title}', error: e, stackTrace: stack);

      // Return a fallback reflection
      return 'This was a meaningful moment in your day. Take a moment to reflect on what made it special, how it made you feel, and what insights you might gain from this experience.';
    }
  }

  /// Extract activities for a specific date
  Future<List<Map<String, dynamic>>> _extractActivitiesForDate(DateTime date) async {
    final activities = <Map<String, dynamic>>[];
    final startOfDay = DateTime(date.year, date.month, date.day);
    final endOfDay = startOfDay.add(const Duration(days: 1));

    try {
      // Get location data
      final locationPoints = await _databaseService.locationDb.getLocationPointsBetween(startOfDay, endOfDay);
      if (locationPoints.isNotEmpty) {
        activities.add({
          'type': 'location',
          'description': 'Visited ${locationPoints.length} locations throughout the day',
          'metadata': {
            'point_count': locationPoints.length,
            'first_location': {
              'lat': locationPoints.first.latitude,
              'lon': locationPoints.first.longitude,
            },
            'last_location': {
              'lat': locationPoints.last.latitude,
              'lon': locationPoints.last.longitude,
            },
          },
          'timestamp': locationPoints.first.timestamp,
        });
      }

      // Get movement data
      final movementData = await _databaseService.locationDb.getMovementDataBetween(startOfDay, endOfDay);
      if (movementData.isNotEmpty) {
        final totalSamples = movementData.fold(0, (sum, data) => sum + data.sampleCount);
        final averageStillTime = movementData.fold(0.0, (sum, data) => sum + data.stillPercentage) / movementData.length;

        activities.add({
          'type': 'movement',
          'description': 'Movement patterns recorded throughout the day',
          'metadata': {
            'total_samples': totalSamples,
            'average_still_percentage': averageStillTime,
            'activity_changes': movementData.length,
          },
          'timestamp': movementData.first.timestamp,
        });
      }

      // Get media from the day
      final mediaItems = await _databaseService.mediaDb.getRecentMedia(
        duration: const Duration(days: 1),
        limit: 50,
      );
      final todayMedia = mediaItems.where((item) {
        return item.createdDate.isAfter(startOfDay) && item.createdDate.isBefore(endOfDay);
      }).toList();

      if (todayMedia.isNotEmpty) {
        activities.add({
          'type': 'photo',
          'description': 'Captured ${todayMedia.length} photos and memories',
          'metadata': {
            'media_count': todayMedia.length,
            'first_photo': todayMedia.first.fileName,
          },
          'timestamp': todayMedia.first.createdDate,
        });
      }

    } catch (e, stack) {
      _logger.warning('Failed to extract some activities for ${date.toIso8601String()}', error: e, stackTrace: stack);
    }

    return activities;
  }

  /// Setup daily timer to create entries
  void _setupDailyTimer() {
    final now = DateTime.now();
    final tomorrow = DateTime(now.year, now.month, now.day + 1);
    final timeUntilMidnight = tomorrow.difference(now);

    _logger.info('Setting up daily timer - next entry in ${timeUntilMidnight.inHours}h ${timeUntilMidnight.inMinutes % 60}m');

    // Create timer for tomorrow's midnight
    _dailyTimer = Timer(timeUntilMidnight, () {
      _createDailyEntry();

      // Setup recurring daily timer
      _dailyTimer = Timer.periodic(const Duration(days: 1), (_) {
        _createDailyEntry();
      });
    });
  }

  /// Create daily entry automatically
  Future<void> _createDailyEntry() async {
    final yesterday = DateTime.now().subtract(const Duration(days: 1));
    _logger.info('Creating automatic daily entry for ${yesterday.toIso8601String()}');

    try {
      final existingEntry = await _journalDb.getJournalEntryForDate(yesterday);
      if (existingEntry == null) {
        await createEntryForDate(yesterday);
        _logger.info('Created automatic daily entry for ${yesterday.toIso8601String()}');
      } else {
        _logger.info('Daily entry already exists for ${yesterday.toIso8601String()}');
      }
    } catch (e, stack) {
      _logger.error('Failed to create automatic daily entry for ${yesterday.toIso8601String()}', error: e, stackTrace: stack);
    }
  }

  /// Ensure today's entry exists
  Future<void> _ensureTodayEntry() async {
    final today = DateTime.now();
    final existingEntry = await _journalDb.getJournalEntryForDate(today);

    if (existingEntry == null) {
      _logger.info('No entry found for today, creating one...');
      await createEntryForDate(today);
    } else {
      _logger.info('Today\'s entry already exists: ${existingEntry.title}');
    }
  }

  /// Format date for display
  String _formatDate(DateTime date) {
    final months = [
      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
    ];
    return '${months[date.month - 1]} ${date.day}, ${date.year}';
  }


}